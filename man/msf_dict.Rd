% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_data.R, R/msf_dict_survey.R
\name{msf_dict}
\alias{msf_dict}
\alias{msf_dict_rename_helper}
\alias{gen_data}
\alias{msf_dict_survey}
\title{MSF data dictionaries and dummy datasets}
\usage{
msf_dict(
  disease,
  name = "MSF-outbreak-dict.xlsx",
  tibble = TRUE,
  compact = TRUE,
  long = TRUE
)

msf_dict_rename_helper(
  disease,
  varnames = "data_element_shortname",
  copy_to_clipboard = TRUE
)

gen_data(dictionary, varnames = "data_element_shortname", numcases = 300)

msf_dict_survey(
  disease,
  name = "MSF-survey-dict.xlsx",
  tibble = TRUE,
  compact = FALSE
)
}
\arguments{
\item{disease}{Specify which disease you would like to use.
Currently supports "Cholera", "Measles" and "Meningitis".}

\item{name}{the name of the dictionary stored in the package.}

\item{tibble}{Return data dictionary as a tidyverse tibble (default is TRUE)}

\item{compact}{if \code{TRUE} (default), then a nested data frame is returned
where each row represents a single variable and a nested data frame column
called "options", which can be expanded with \code{\link[tidyr:unnest]{tidyr::unnest()}}. This only
works if \code{long = TRUE}.}

\item{long}{If TRUE (default), the returned data dictionary is in long format with
each option getting one row. If \code{FALSE}, then two data frames are returned,
one with variables and the other with content options.}

\item{varnames}{Specify name of column that contains varnames. Currently
default set to "Item".  (this can probably be deleted once dictionaries
standardise) If \code{dictionary} is "Mortality", \code{varnames} needs to be "column_name"`.}

\item{copy_to_clipboard}{if \code{TRUE} (default), the rename template will be
copied to the user's clipboard with \code{\link[clipr:write_clip]{clipr::write_clip()}}. If \code{FALSE}, the
rename template will be printed to the user's console.}

\item{dictionary}{Specify which dictionary you would like to use.
Currently supports "Cholera", "Measles", "Meningitis", "AJS" and "Mortality".}

\item{numcases}{For fake data, specify the number of cases you want (default is 300}
}
\description{
These function reads in MSF data dictionaries and produces randomised
datasets based on values defined in the dictionaries.  The randomised
dataset produced should mimic an excel export from DHIS2.
}
\examples{

if (require('dplyr') & require('linelist')) { withAutoprint({
# You will often want to use MSF dictionaries to translate codes to human-
# readable variables. Here, we generate a data set of 20 cases:
dat <- gen_data(dictionary = "Cholera", varnames = "data_element_shortname",
                numcases = 20)
print(dat)

# We want the expanded dictionary, so we will select `compact = FALSE`
dict <- msf_dict(disease = "Cholera", long = TRUE, compact = FALSE, tibble = TRUE)
print(dict)

# We can use linelist's clean_variable_spelling to translate the codes. First,
# we want to reorder the columns of the dictionary like so:
#
#  - 1st column: option codes
#  - 2nd column: translations
#  - 3rd column: data column name
#  - 4th column: order of options
#
# we also want to make sure to filter out any columns that are blank for
# the option codes, because this means that they don't have a fixed number of
# options
dict <- dict \%>\%
  select(option_code, option_name, data_element_shortname, option_order_in_set) \%>\%
  filter(!is.na(option_code))
print(dict)

# Now we can use linelist to filter the data:
dat_clean <- clean_variable_spelling(dat, dict)
print(dat_clean)
})}
}
\seealso{
\code{\link[linelist:clean_variable_spelling]{linelist::clean_variable_spelling()}}
}
