---
title: "Outbreak report"
output: github_document
---


# Introduction to this template

This is a template which can be used to create an automated outbreak situation
report.

- It is organised by time, place and person. 
- You can type normal text in white spaces (such as here) and r-code in grey
    spaces (denoted by three backticks and r) (see [Rmarkdown
    introduction](https://rmarkdown.rstudio.com/articles_intro.html) and
    [Markdown basics](https://rmarkdown.rstudio.com/authoring_basics.html))
- Introductions and contents of sections are within square brackets "[...]" and
    can be deleted as appropriate
- Examples of inline code (to automate updating numbers, e.g. line 148), can
    similarly be removed/updated
- Code itself can be deleted, but as a word of caution: make sure you aren't
    deleting bits where variables are created/manipulated, or at least update
    them appropriatley
- ADD LIST ON WHICH PACKAGES WILL BE USED FOR WHAT REASONS! AND HOW TO INSTALL
- OTHER INFO TO ADD??


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, error = TRUE)
options(knitr.kable.NA = "-")
library(knitr) # for creating output doc
library(dplyr) # for cleaning/shaping data
library(ggplot2) # for plotting diagrams

# epi packages
library(sitrep) # for msf field epi functions
library(incidence) # for epicurves
library(ISOweek) # for creating epiweeks
library(epitools) # for creating 2by2 tables
```





```{r read_data}
## Read data ------------------------------------
# CSV file
# linelist_raw <- rio::import("linelist.csv")
#
# Excel file
# linelist_raw <- rio::import("linelist.xlsx")
#
# Stata data file
# linelist_raw <- rio::import("linelist.dat")

linelist_raw <- outbreaks::fluH7N9_china_2013

## Fixing variable names ----------------------

# a good first step is to assign standard column names so that subsequent code
# uses stable column names. 
# in case the input data changes, you just need to fix the column mapping


# make a copy of your original dataset and name it linelist_cleaned
linelist_cleaned <- linelist_raw

# define clean variable names using clean_labels from the epitrix package
# this function is preset rules for variable naming 
# for example it changes spaces and dots to "_" and characters to lowercase
cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))

# overwrite variable names with defined clean names
colnames(linelist_cleaned) <- cleaned_colnames

# you can also change specific var names using the *rename* function
linelist_cleaned <- rename(linelist_cleaned, sex = gender)
```


```{r clean_data}
# THIS CAN BE DELETED WHEN WE USE A DIFFERENT DATASET 
# its just to be able to demonstrate posibilities

# generate artificial lab tests, symptoms and contact vars
lab_results <- linelist_cleaned %>% 
                select(case_id) %>% 
                mutate(test_result = sample(c("Positive", "Negative"),
                                            nrow(linelist_cleaned), 
                                            replace = TRUE), 
                       symptoms = sample(c("Yes", "No"),
                                            nrow(linelist_cleaned), 
                                            replace = TRUE),
                       contact = sample(c("Yes", "No"),
                                            nrow(linelist_cleaned), 
                                            replace = TRUE)
                )

# generate some artificial population data
population_data <- distinct(linelist_cleaned, province)
population_data$population <- as.integer(runif(nrow(population_data), 
                                          min = 10^3, max = 10^5))
```







```{r browse_data, eval = FALSE}
# Browsing data ---------------------------------
# here are a few ways to do data explorations 

# view the first ten rows of data
head(linelist_cleaned, n = 10)

# view your whole dataset interactivley (in an excel style format)
## Remember that `View` needs to be written with a capital *V*
if (interactive()) View(linelist_cleaned)

# overview of variable types and contents
str(linelist_cleaned)

# gives mean, median and max values of variables
summary(linelist_cleaned)

# view unique values contained in variables 
unique(linelist_cleaned$sex)

# another alternative is with the "summarytools package"
# use the dfSummary function in combination with view
# note that view is not capitalised with this package
# install.packages("summarytools")
# view(summarytools::dfSummary(linelist_cleaned))
```






```{r merge_lab_results}
# merging linelist with lab dataset 
linelist_cleaned <- left_join(linelist_cleaned, lab_results, 
                              by = "case_id")
```



```{r standardise_data}
# Next, document anything to clean data. Use dplyr for that.

# create an age group variable by specifying categorical breaks
linelist_cleaned$age_group <- age_categories(linelist_cleaned$age, 
                                             breakers = c(0, 5, 10, 30, 50, 80))

# alternatively, create an age group variable specify a sequence
# linelist_cleaned$age_group <- age_categories(linelist_cleaned$age,
#                                              lower = 0, 
#                                              upper = 100, 
#                                              by = 10)


# Change the levels of a categorical variable
linelist_cleaned$sex <- recode_factor(linelist_cleaned$sex, 
                                      f = "Female", 
                                      m = "Male")

# create a case definition variable 
linelist_cleaned$case_def <- ifelse(linelist_cleaned$test_result == "Positive", 
                                    "Confirmed", "Suspected")
linelist_cleaned$case_def[linelist_cleaned$case_def != "Confirmed" & 
                            linelist_cleaned$symptoms == "Yes"] <- "Probable"

# create an epiweek variable 
linelist_cleaned$epiweek <- ISOweek(linelist_cleaned$date_of_onset)

# ... TODO: add some snippets for cleaing data
# TODO: showcase and recommend the linelist package
```


```{r remove_personally_identifiable_information}
# You might want to remove columns and other personal data

# remove a hypothetical variable called "name" 
# this var doesnt actually exist in our dataset
linelist_cleaned$name <- NULL
```





### Person

* [Who is affected: how many in total; male or female; young, adult or old? What are the links between affected people â€“ work place, school, social gathering?  Is there a high rate of illness in contacts?  Is there a high rate of illness in health workers? You may want to include:  a bar chart showing case numbers or incidence by age group and sex; attack rates (AR); and numbers of deaths (in suspected and confirmed cases), mortality rates and/or case fatality ratio (CFR)]  



In total there were `r nrow(linelist_cleaned)` cases. There were
`r linelist_cleaned %>% filter(sex == "Female") %>% count()` females affected and
`r linelist_cleaned %>% filter(sex == "Male") %>% count()` males. 

The most affected age group was `r descriptive(linelist_cleaned, "age_group") %>% slice(which.max(n)) %>% select(age_group)` years. 


#### Age

Cases by sex

```{r describe_by_sex}
# get counts and proportions of cases by sex
descriptive(linelist_cleaned, "sex") %>%
  # change table column names 
  # rename( new variable name = old variable name)
  rename("Sex" = sex, "Cases (n)" = n,"Proportion (%)" =  prop) %>% 
  kable(digits = 2)
```

Cases by age group.


```{r describe_by_age_group} 
# get counts and proportions by age group
descriptive(linelist_cleaned, "age_group") %>%
  # change variable names 
  rename("Age group (years)" = age_group, 
         "Cases (n)" = n,
         "Proportion (%)" = prop) %>% 
  kable(digits = 2)
```



Cases by age group and definition 

```{r describe_by_age_group_and_def}
# get counts and props of age groups by case definition 
# include column and row totals 
descriptive(linelist_cleaned, "age_group", "case_def", coltotals = TRUE, rowtotals = TRUE) %>% 
  rename("Age group (years)" = age_group, 
         "Confirmed cases (n)" = Confirmed_n, 
         "%" = Confirmed_prop, 
         "Probable cases (n)" = Probable_n, 
         "%" = Probable_prop,
         "Suspected cases (n)" = Suspected_n, 
         "%" = Suspected_prop) %>% 
  kable(digits = 2)
```




Cases by age group and sex 

```{r describe_by_age_group_and_sex}
descriptive(linelist_cleaned, "age_group", "sex") %>% 
  rename("Age group (years)" = age_group, 
         "Female cases (n)" = Female_n, 
         "%" = Female_prop, 
         "Male cases (n)" = Male_n, 
         "%" = Male_prop,
         "Missing (n)" = NA_n, 
         "%" = NA_prop) %>% 
  kable(digits = 2)
```


```{r filter_case_def_describe, eval = FALSE}

# you can also subset a descriptive table
#
# for example to only have confirmed cases 
filter(linelist_cleaned, case_def == "Confirmed") %>%
  descriptive("age_group", "sex") %>% 
  kable(digits = 2)


# alternatively you could show a single age group 
filter(linelist_cleaned, age_group == "10-29") %>%
  descriptive("age_group", "sex") %>% 
  kable(digits = 2)
```


Age pyramid


```{r age_pyramid}
plot_age_pyramid(linelist_cleaned, age_group = "age_group", split_by = "sex")
```


CFR 

The case fatality ratio among those with known outcomes is below

```{r identify_deaths}
# define your input variables in advance to pass through CFR function
known_status <- linelist_cleaned[!is.na(linelist_cleaned$outcome), ]
deaths <- sum(linelist_cleaned$outcome == "Death", na.rm = TRUE)
population <- length(linelist_cleaned$outcome[!is.na(linelist_cleaned$outcome)])
```


```{r overall_cfr}
# use arguments from above to produce overal CFR
linelist_cleaned %>% 
  filter(!is.na(outcome)) %>%                     # remove rows with missing outcome
  summarise(deaths = sum(outcome == "Death"),    # tally deaths
            population = n()) %>%                # count population
  do(case_fatality_rate(.$deaths, .$population)) # calculate case fatality rate
  rename("Deaths" = deaths,
         "Population" = population,
         "CFR (%)" = cfr,
         "Lower 95% CI" = lower,
         "Upper 95% CI" = upper) %>%
  knitr::kable(digits = 2)                       # print nicely with 2 digits
```

CFR by sex 


```{r, cfr_by_sex}
# group by known outcome and sex
linelist_cleaned %>% 
  filter(!is.na(outcome)) %>%                     # remove rows with missing outcome
  group_by(sex) %>%                              # group by sex
  summarise(deaths = sum(outcome == "Death"),    # tally deaths
            population = n()) %>%                # tally population
  do(bind_cols(sex = .$sex, case_fatality_rate(.$deaths, .$population))) %>% # calculate case fatality rate
  arrange(desc(lower)) %>%                       # sort by lower confidence interval
  rename("Sex" = sex, 
         "Deaths" = deaths, 
         "Population" = population, 
         "CFR (%)" = cfr, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  knitr::kable(digits = 2)
```



CFR by age group

```{r cfr_by_age_group}
# group by known outcome and agegroup 
linelist_cleaned %>% 
  filter(!is.na(outcome)) %>%                     # remove rows with missing outcome
  group_by(age_group) %>%                        # group by age_group
  summarise(deaths = sum(outcome == "Death"),    # tally deaths
            population = n()) %>%                # tally population
  do(bind_cols(age_group = .$age_group, case_fatality_rate(.$deaths, .$population))) %>% # calculate case fatality rate
  arrange(desc(lower)) %>%                       # sort by lower confidence interval
  complete(age_group) %>%                        # Ensure all levels are represented
  rename("Age group (years)" = age_group, 
         "Deaths" = deaths, 
         "Population" = population, 
         "CFR (%)" = cfr, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  knitr::kable(digits = 2)
```

CFR by case definition 


```{r cfr_by_case_def}
# group by known outcome and case definition 
linelist_cleaned %>% 
  filter(!is.na(outcome)) %>%                     # remove rows with missing outcome
  group_by(case_def) %>%                         # group by case_def
  summarise(deaths = sum(outcome == "Death"),    # tally deaths
            population = n()) %>%                # tally population
  do(bind_cols(case_def = .$case_def, case_fatality_rate(.$deaths, .$population))) %>% # calculate case fatality rate
  arrange(desc(lower)) %>%                       # sort by lower confidence interval
  complete(case_def) %>%                         # Ensure all levels are represented
  rename("Case definition" = case_def, 
         "Deaths" = deaths, 
         "Population" = population, 
         "CFR (%)" = cfr, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  knitr::kable(digits = 2)
```






#### Attack rate

The attack rate per 100,000 population is below - based on available population data for the whole country. 

```{r attack_rate}
# define population 
population <- sum(population_data$population)

attack_rate(nrow(linelist_cleaned), population, multiplier = 100000) %>% 
  rename("Cases (n)" = cases,
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  knitr::kable(digits = 2)
```

The below gives the attack rate per week. 

```{r attack_rate_per_week}
# cases for each week
cases <- count(linelist_cleaned, epiweek)

# attack rate for each week
attack_rate(cases$n, population, multiplier = 100000) %>% 
  # add the epiweek column to table
  bind_cols(select(cases, epiweek), .) %>% 
  rename("Epiweek" = epiweek, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  knitr::kable(digits = 2)
```
 
The below gives the cummulative attack rate per week. 

```{r cummulative_attack_rate_per_week}
# cummulative counts by week
cases <- count(linelist_cleaned, epiweek) %>% 
  mutate(cummulative = cumsum(n))

# cummulative attack rate by week
attack_rate(cases$cummulative, population, multiplier = 100000) %>% 
  # add the epiweek column to table
  bind_cols(select(cases, epiweek), .) %>% 
  rename("Epiweek" = epiweek, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  knitr::kable(digits = 2)
```


#### Mortality

Mortality rate per 100,000:

```{r mortality_rate}
mortality_rate(deaths, population, multiplier = 10^4) %>%
  kable(digits = 2)
```


#### 2x2 tables

```{r two_by_two, message = FALSE, warning = FALSE}
outcome <- linelist_cleaned$outcome == "Death"
is_male <- linelist_cleaned$sex == "Male"
is_child <- as.integer(linelist_cleaned$age) <= 12

univariate_analysis(measure = "OR", 
                    digits = 3, 
                    outcome = outcome, 
                    is_male, 
                    is_child) %>% 
  rename("Exposure" = exposure, 
         "Exposed cases (n)" = exp_cases, 
         "Unexposed cases (n)" = unexp_cases,  
         "Case odds" = cases_odds,
         "Exposed controls (n)" = exp_noncases, 
         "Unexposed controls (n)" = unexp_noncases,
         "Control odds" = noncases_odds,
         "OR" = estimate,
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper, 
         "p" = p_value
         ) %>% 
  # clean names of exposures 
  mutate(Exposure = recode(Exposure, 
                           is_male = "Sex (male)", 
                           is_child = "Age (<12yrs)")) %>% 
  knitr::kable(digits = 2)
```


### Time

* [When did the cases fall ill? Are numbers increasing or stable? You may want to include an Epi curve (bar chart showing number of new (suspected and confirmed) cases each day/week) ]


There were `r sum(is.na(linelist_cleaned$date_of_onset))` cases missing dates of onset. 

```{r create_incidence, message = FALSE}
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, interval = 7)
```

The peak of the outbreak was in `r find_peak(inc_week_7)`

```{r epicurve, message = FALSE}
# plot your epicurve
plot(inc_week_7, show_cases = TRUE, border = "black") + 
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  theme_classic() + # give classic black/white graph 
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "Cases (n)", 
       captions = "Source: MoH of China data on xx/yy/zzzz") + 
  # change visuals of dates and remove legend title
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
        legend.title = element_blank()) + 
  # change interval of date labels
  scale_x_date(date_breaks = "1 week")
```

You may also want to stratify by gender. 


```{r incidence_by_gender, message = FALSE}
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, 
                        interval = 7, 
                        groups = linelist_cleaned$sex)


plot(inc_week_7, show_cases = TRUE, border = "black") + 
  labs(x = "Calendar week", y = "Cases (n)") + 
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  theme_classic() + # give classic black/white graph 
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "Cases (n)", 
       captions = "Source: MoH of China data on xx/yy/zzzz") + 
  # change visuals of dates and remove legend title
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
        legend.title = element_blank()) + 
  # change interval of date labels
  scale_x_date(date_breaks = "1 week")
```


You could similarly stratify by case definition (or any other categorical variable!)


```{r incidence_by_case_def, message = FALSE}
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, 
                        interval = 7, 
                        groups = linelist_cleaned$case_def)


plot(inc_week_7, show_cases = TRUE, border = "black") + 
  labs(x = "Calendar week", y = "Cases (n)") + 
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  theme_classic() + # give classic black/white graph 
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "Cases (n)", 
       captions = "Source: MoH of China data on xx/yy/zzzz") + 
  # change visuals of dates and remove legend title
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
        legend.title = element_blank()) + 
  # change interval of date labels
  scale_x_date(date_breaks = "1 week")
```


Alternatively, you could stratify by sex among a subset of only confirmed cases. 


```{r incidence_by_sex_confirmed, message = FALSE}
inc_week_7 <- incidence(linelist_cleaned$date_of_onset[linelist_cleaned$case_def == "Confirmed"], 
                        interval = 7, 
                        groups = linelist_cleaned$sex[linelist_cleaned$case_def == "Confirmed"])


plot(inc_week_7, show_cases = TRUE, border = "black") + 
  labs(x = "Calendar week", y = "Cases (n)") + 
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  theme_classic() + # give classic black/white graph 
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "Cases (n)", 
       captions = "Source: MoH of China data on xx/yy/zzzz") + 
  # change visuals of dates and remove legend title
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
        legend.title = element_blank()) + 
  # change interval of date labels
  scale_x_date(date_breaks = "1 week")
```





### Place

*  [Across what area: one or several villages, all from same school, etc. You may want to include a map of the distribution of cases; attack rates by location]


#### Maps


If you do not have spatial data available, it may be worth calculating attack rates by region. 

```{r attack_rate_by_region}
cases <- count(linelist_cleaned, province) %>%   # cases for each week
  left_join(population_data, by = "province")    # merge population data 

# attack rate for each week
attack_rate(cases$n, cases$population, multiplier = 100000) %>% 
  # add the epiweek column to table
  bind_cols(select(cases, province), .) %>% 
  rename("Province" = province, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  knitr::kable(digits = 2)
```






The following is one example of how to use and display spatial data. 

```{r spatial_packages, message = FALSE, warning = FALSE}
# spatial packages 
# library(raster) # for downloading GADM shapefiles
library(tmap) # for plotting maps
library(tmaptools) # for tiles and spatial operations (kernel densities) 
library(sf) # for manipulating spatial objects easily
```




```{r download_spatial_maps, message=FALSE}

# reading in a shapefile 
# map <- read_sf(here("mapfolder", "china.shp"))


# download administrative boundaries 

## view ISO3 codes for countries 
# raster::getData("ISO3") 

## retrieve province boundaries from the Global Administrative 
## level = 1 specifies provinces 
## must be possible to do this as sf directly no? Is available on GADM.org
map <- raster::getData("GADM", country = "CN", level = 1)

## changing GADM to a sf object 
map <- st_as_sf(map)

```




```{r subset_shapefiles, message = FALSE, warning = FALSE}
# subsetting shapefiles 

# Subset map to provinces of interest
mapsub <- map %>% filter(NAME_1 %in% unique(linelist_cleaned$province))

# change projection of subset 
mapsub <- set_projection(mapsub, current.projection = "longlat", projection = 4326, overwrite.current.projection = TRUE)

# simplify the shapefile (small islands in china sea)
mapsub <- simplify_shape(mapsub, fact = 1)
```




```{r random_points, message = FALSE}

# get random points in provinces occuring 
## CAN BE DELETED ONCE WE USE A BETTER DATASET
## stupid work around because st_sample hasnt implemented exact number points yet

## get points
a <- st_sample(mapsub, nrow(linelist_cleaned), type = "random") %>% 
  st_cast("POINT") %>% 
  st_coordinates() %>% 
  data.frame() %>%
  setNames(c("lon", "lat"))

## fix if too many or too few points
if (nrow(a) < nrow(linelist_cleaned)) {
  b <- matrix(rep.int(c(NA, NA), nrow(linelist_cleaned) - nrow(a)), ncol = 2)
  colnames(b) <- c("lon", "lat")
  a <- rbind(a, b)
}

if (nrow(a) > nrow(linelist_cleaned)) {
  a <- a[1:nrow(linelist_cleaned), ]
}

## merge to linelist
linelist_cleaned <- bind_cols(linelist_cleaned, a)

```





```{r download_tiles, message=FALSE}
# downloading basemap tiles 

## view available basemaps at http://leaflet-extras.github.io/leaflet-providers/preview/
## Not all available - we need to find a better option 
osm_tiles <- tmaptools::read_osm(bb(mapsub, projection = "longlat"), ext = 1.05, type =  "osm")

## Alternative specify box
## If do not have a shapefile - choose based on coordinates (or name of place) 
# osm_tiles <- tmaptools::read_osm(bb(xlim = c(108.78, 122.94), ylim = c(20.22, 42.61)))

```



```{r plot_map, message = FALSE}

# plot your basemap
basemap <- tm_shape(osm_tiles) + # osm tiles
  tm_raster() + #osm tiles as an image
  tm_shape(mapsub) + # shapefile
  tm_polygons(col = NA, alpha = 0) + # shapefile as polygon
  tm_layout(frame = FALSE) + # remove frame around plot
  tm_compass(position = c("right", "top")) + # add a north compass
  tm_scale_bar(breaks = c(0,250, 500), size = 1) # add a scalebar

# save basemap for later offline use  
# save(basemap, file = here::here("base.rda"))

# load basemap when need it offline
# load(file = here::here("base.rda"))
```


```{r create_sf_from_linelist, message = FALSE}
# make linelist available for plotting 
## this could probably be done directly in linelist_cleaned
## unsure how other functions would react to an sf + dataframe obj though
cases <- st_as_sf(linelist_cleaned, coords = c("lon", "lat"))
cases <- set_projection(cases, current.projection = "longlat", projection = 4326)
```

##### Dot maps
```{r dot_maps, message = FALSE}
# dotmap 
basemap + 
  tm_shape(cases) + 
  tm_dots(col = "case_def",  
          palette = "Dark2", size = 0.5, 
          title = "Case definition") + 
  tm_layout(legend.outside = TRUE)
```

##### Choropleth maps

```{r choropleth_maps, message = FALSE, warning = FALSE}
# choropleth 

## get counts by provinces 
counts <- count(linelist_cleaned, province) 

## merge population and get AR per 100000
counts <- left_join(counts, population_data, by = "province") %>% 
  mutate(AR = n/population * 100000)


## add counts to map data 
mapsub <- left_join(mapsub, counts, by = c("NAME_1" = "province"))

# plot choropleth
basemap + 
  tm_shape(mapsub) + 
  tm_polygons(col = "AR", 
              border.col = "black", 
              title = "AR per 100000 population") + 
  tm_layout(legend.outside = TRUE)
```



#### Mortality rate per district

```{r mortality_rate_per_district}

linelist_cleaned %>%
  filter(!is.na(outcome)) %>%                     # remove missing outcomes
  group_by(province) %>%                         # group the provinces
  summarise(deaths = sum(outcome == "Death"),    # tally deaths
            population = n()) %>%                # tally population
  do(bind_cols(province = .$province, mortality_rate(.$deaths, .$population, multiplier = 10^3))) %>% # calculate mortality rate
  arrange(desc(lower)) %>%                       # sort by lower confidence interval
  complete(province) %>%                         # Ensure all levels are represented
  rename("Province" = province, 
    "Number of deaths" = deaths, 
    "Population" = population,
    "Mortality per 1,000" = `mortality per 1 000`, 
    "Lower 95% CI" = lower, 
    "Upper 95% CI" = upper
  ) %>% 
  kable(digits = 3)
```

