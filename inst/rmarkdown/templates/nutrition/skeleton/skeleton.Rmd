---
title: "Nutrition survey"
output: 
  word_document:
    keep_md: true
---


# Introduction to this template

This is a template which can be used to create a report from a nutrition survey. 

- There are sections for reading and cleaning data, followed by 
    weighting and observation time calculations and then survey analysis. 
    Use the drop-down menu on the bottom left of this script window to jump 
    between sections. 
- You can type normal text in white spaces (such as here) and r-code in grey
    spaces (denoted by three backticks and r) (see [Rmarkdown
    introduction](https://rmarkdown.rstudio.com/articles_intro.html) and
    [Markdown basics](https://rmarkdown.rstudio.com/authoring_basics.html))
- Introductions and contents of sections are within square brackets "[...]" and
    can be deleted as appropriate
- Examples of inline code (to automate updating numbers, e.g. in the "Results
    section"), can similarly be removed/updated
- Code itself can be deleted, but as a word of caution: make sure you aren't
    deleting bits where variables are created/manipulated, or at least update
    them appropriatley
- For a more detailed exaplanation of this template, see [Wiki](https://github.com/R4EPI/sitrep/wiki)

This template will guide you through the following steps:  
  - merging household and individual level data
  - calculating anthropometric indicators based on z-score counts 
  - calculating anthropometric indicators based on weighted z-score counts


## Data analysis: Definitions and standards

We used the following definitions for the analysis of the survey results for Weight for Height z-scores (WHZ):

* Global acute malnutrition (GAM): a WHZ score of less than (<) -2 and/or oedema;
* Moderate acute malnutrition: WHZ score <-2 and â‰¥ -3 and no oedema; 
* Severe acute malnutrition (SAM): WHZ score <-3 and/or oedema.

We used the following definitions for the analysis of the survey results for MUAC measurements:

* Global acute malnutrition (GAM): MUAC of <125mm and/or oedema;
* Moderate acute malnutrirtion: MUAC <125mm and >= 115mm and no oedema;
* Severe acute malnutrition (SAM): MUAC <115mm and/or oedema.

In order to estimate stunting in the surveyed population, we looked at Height for Age z-scores (HAZ) and used the following definitions:

* Stunting: HAZ score <-2;
* Moderate stunting: HAZ score >=-3 and <-2; 
* Severe stunting: HAZ score <-3.


In order to estimate underweight in the surveyed population, we looked at Weight for Age z-scores (WAZ) and used the following definitions: 
* Underweight: WAZ score < -2; 
* moderate underweight: WAZ score >=-3 and <-2; 
* Severe underweight: WAZ <-3


Exclusion of z-scores from Observed mean SMART flags included:
* WHZ: <-5 or >5; 
* HAZ: <-6 or >6; 
* WAZ: <-6 or >5.


## Installing and loading required packages 

Several packages are required for different aspects of  analysis with *R*. 
You will need to install these before starting. 
We will be using the following packages. Some of these packages automatically
install other packages they need to work (called dependencies).

These packages can be quite large and may take a while to download in the
field. If you have access to a USB key with these packages, it makes sense to
copy and paste the packages into Program Files/R/R-[version]/library.



```{r setup, include = FALSE, results='hide', message=FALSE, warning=FALSE}
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = FALSE, error = TRUE, fig.width = 6*1.25, fig.height = 6)
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")

# Installing required packages for this template
required_packages <- c("knitr",       # create output docs
                       "rio",         # for importing data
                       "epitrix",     # clean/shape data
                       "dplyr",       # clean/shape data
                       "tidyr",       # clean/shape data
                       "forcats",     # clean/shape data
                       "ggplot2",     # create plots and charts
                       "sitrep",      # MSF field epi functions
                       "anthro",       # WHO Child Growth Standards (wrapper of survey)
                       "survey",      # for survey functions
                       "srvyr"        # dplyr wrapper for survey package
                       )

for (pkg in required_packages) {
  # install packages if not already present
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }
  
  # load packages to this current session 
  library(pkg, character.only = TRUE)
}
# set default text size to 16 for plots
# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))
```




```{r read_data_generic, message = FALSE}

## This section gives a variety of options for reading in datasets in different formats

## Read data ------------------------------------
# CSV file
# linelist_raw <- rio::import("linelist.csv")
#
# Excel file
# to read in a specific sheet use "which"
# linelist_raw <- rio::import("linelist.xlsx", which = "Sheet1")
#
# Stata data file
# linelist_raw <- rio::import("linelist.dat")
#
# For password protected Excel file 
# use the excel.link package 
# library(excel.link)
# linelist_raw <- excel.link::xl.read.file("linelist.xlsx",
#                                          xl.sheet = "Sheet1",
#                                          password = askpass::askpass(prompt = "please enter file
#                                                                      password"))

```





```{r read_dharma_excel_data, message = FALSE}

# If your linelist is an excel export of data from Dharma use this code chunk
# If that is not the case use the code chunk above reading in other formats

## Read data ------------------------------------------------------

# This assums that you have two levels in your survey (level 0 and level 1). 
# These correspond to, for example, household and individual. 
# We will read in and later merge these two levels in to one dataset. 
# We will assume the data is not password protected (code for reading 
# password protected excels is in the read_data_generic code chunk)

## read in household data sheet
# study_data_hh <- rio::import("nutrition_survey.xlsx", 
#                               which = "Level 0 Named", na = ".")

## read in individual level data sheet
# study_data_indiv <- rio::import("nutrition_survey.xlsx", 
#                               which = "Level 1 Named", na = ".")

## DELETE THIS LINE --- YOU READ IN YOUR OWN DATA ABOVE!
# generates a fake dataset for use as an example in this template
study_data_raw <- gen_data(dictionary = "Nutrition", 
                         varnames = "column_name",
                         numcases = 1000)

## Data dictionary ---------------
## The data dictionary has variable names in the "column_name" column.
## Possible values for variables are specified in the "choice_code" and "choice_name"
## columns. 
## Where code has the shortened values and name has the full text values.

# read in data dictionary (for reference purposes)
# study_data_dict <- import("nutrition_survey.xlsx",
#                       which = "Data Dictionary")

## you can look at the dictionary by uncommenting the line below
# View(study_data_dict) 

## you can view variable names in the data dicationry uncommenting the line below
# study_data_dict$column_name

## DELETE THIS LINE --- YOU READ IN YOUR OWN DATA ABOVE!
# generates a fake dataset for use as an example in this template
# this dataset already has the two levels merged
# variable names are in the column_name column
# possible values for each variable are specified in the "Code" columns.
study_data_dict <- msf_dict_survey("Nutrition")
```



```{r merge_data_levels}

## Need to merge individual data with household data
## This is done using a unique identifier for the household 
## (which repeats in the individuals dataset) 
## For a Dharma dataset this variable is "fact_0_id"

## fact_0_id, the merging variable, needs to be applied to all relevant rows in the indidivual data set
## (equivalent of dragging down with mouse in excel)
## this is achieved using the fill function from the tidyr package
# study_data_indiv <- study_data_indiv %>%
#                       fill(fact_0_id)

## join the individual and household data to form a complete data set
#study_data_raw <- left_join(study_data_hh, study_data_indiv, by = "fact_0_id")
```








```{r read_population_data, warning = FALSE, message = FALSE}

## There are two options for using population data here. 
## The first one is where you only know the total population number, and the 
## proportion breakdown for categories (e.g. by age group, sex or region). 
## The second option is to read in population from excel. 
## In both cases you will need to make sure that the respective groups for 
## population fit the groups in your linelist data set!
##
## Checklist for population data ----------------------------------------------
## 
## - [ ] Decide if you have stratified population data available as counts or only proportions
## - [ ] If you have counts available:
##          - [ ] use View on the fake data generated to make sure your format in excel matches
##          - [ ] read in and clean data appropriately in the "Read data" section
##          - [ ] make sure the groups match the appropriate variable in your linelist!
## - [ ] If have total population and proportion breakdown available: 
##          - [ ] use the gen_population function in "counts from populaiton proportions" section
##          - [ ] type in your population, groups, and respective proportions
##          - [ ] group can be any categorical variable you want
##          - [ ] make sure the groups match the appropriate variable in your linelist!
## - [ ] DELETE OR COMMENT OUT THE UNUSED SECTION


## Read data ------------------------------------

## Excel file
## See the gen_population function section below to see how to structure your data!!
## to read in a specific sheet use "which"
# population_data <- rio::import("population.xlsx", which = "Sheet1")

## repeat same cleaning steps as in standardise_clean_data code chunk as appropriate
## make sure your place variable name matches!

## Counts from population proportions ------------------------------------ 
## if you only know the total population and the proportions in each age group, use this function 


# generate population data by age groups in years 
population_data_age <- gen_population(total_pop = 1000, # set the total population 
  groups = c("6-11", "12-23", "24-35", "36-47", "48-60"),    # set the groups
  proportions = c(0.15, 0.11, 0.07, 0.26, 0.182),       # set the proportions for each group
  strata = c("Male", "Female")) %>%                      # stratify by gender 
  rename(age_group = groups,                        # rename columns (syntax is NEW NAME = OLD NAME)
         sex = strata,
         population = n)



# generate population data by age groups in months (under and over 24 months)
population_data_age24 <- gen_population(total_pop = 1000, # set the total population 
  groups = c("0-23", "24-60"),    # set the groups
  proportions = c(0.26, 0.512),       # set the proportions for each group
  strata = c("Male", "Female")) %>%                      # stratify by gender 
  rename(age_group = groups,                        # rename columns (syntax is NEW NAME = OLD NAME)
         sex = strata,
         population = n)

```




```{r browse_data, eval = FALSE}
## Browsing data ---------------------------------
## here are a few ways to do data explorations 

## view the first ten rows of data
head(study_data_raw, n = 10)

## view your whole dataset interactivley (in an excel style format)
## Remember that `View` needs to be written with a capital *V*
View(study_data_raw)

## overview of variable types and contents
str(study_data_raw)

## gives mean, median and max values of variables
## gives counts for categorical variables
## also gives number of NAs
summary(study_data_raw)

## view unique values contained in variables 
unique(study_data_raw$sex)

## check for logical inconsistencies 
## for example check age <6 months and height >100 cm and return corresponding IDs
# (fact_0_id only exists in real dharma datasets - not those from gen_data 
#  function)
study_data_raw %>% 
  filter(age_month < 6 & height > 100) %>% 
  select("fact_0_id")


## another alternative is with the "summarytools package"
## use the dfSummary function in combination with view
## note that view is not capitalised with this package
# install.packages("summarytools")
# summarytools::view(summarytools::dfSummary(study_data_raw))
```




```{r standardise_clean_data}

## All your data cleaning and new variable creation should happen in this chunk. 
## This way, if you mess up all you have to do is push the small arrow at the
## top of this chunk between the cogg and the play buttons, to run all the 
## code chunks up to the current one, then continue your cleaning from where you
## started. 
## 
## YOU WILL NEED TO ADAPT THIS SECTION ACCORDING TO YOUR DATA!
## 
## currently there are examples of cleaning for: 
##    - Date variables 
##    - Numeric variables 
##    - Categorical variables from numerics (e.g. age groups) 
##    - Factor variables (for creating/manipulating categorical variables)
##    - Adding weights based on population 
##    - Dropping rows and columns 


## make a copy of your orginal dataset and name it study_data_cleaned
study_data_cleaned <- study_data_raw


# Clean variable names  ---------------------------------
## define clean variable names using clean_labels from the epitrix package. This
## function defines rules for variable naming; for example, it changes spaces
## and dots to "_" and sets all characters to lowercase.

# overwrite variable names with defined clean names
cleaned_colnames <- epitrix::clean_labels(colnames(study_data_cleaned))
colnames(study_data_cleaned) <- cleaned_colnames 


## Some of the names outputed from Dharma are really long and painful, you can change these as below
## in case you want to specifically change a
## few names you can also change specific var names using the *rename*
## function. 
## The formula for this is rename(data, NEW_NAME = OLD_NAME)
study_data_cleaned <- rename(study_data_cleaned,
                             head_available = q28_cq1,
                             head_adult = q45_cq2,
                             head_consent = q49_cq3,
                             no_consent_other = q61_cq4b)


## OPTIONAL: if you only want to keep certain variables - 
## you can select these by name or column number view the names of your vars
## and their column number using: names(linelist_cleaned) this example keeps
## the first three columns as well as age_years and sex variables

# study_data_cleaned <- select(study_data_cleaned, c(1:3, "age_month", "sex")


# Date variables ---------------------------------

# IF YOU ARE USING A DHARMA DATA DICTIONARY USE THIS OTHERWISE UNCOMMENT LINES BELOW
# make sure all date variables are formatted as dates 

# select all variables which are dates using the data dictionary
# DATEVARS <- filter(study_data_dict, type == "QuestionDate") %>% 
#   select(column_name) # select date vars

# retrieving date vars from the fake dictionary (DELETE THIS)
DATEVARS <- filter(study_data_dict, data_element_valuetype == "DATE") %>% 
  select(column_name) # select date vars

# change to dates 
study_data_cleaned <- study_data_cleaned %>%
  mutate_at(DATEVARS$column_name, as.Date)

# if you dont have a data dictionary you could do it this way too
# study_data_cleaned <- study_data_cleaned %>%
#   mutate_at(vars(matches("date|Date")), as.Date)



# Ideally you should have defined rules in your forms to make sure dates collected are logical
# If not then uncomment the following lines to fix wrong dates (or set them to NA)
# Fixing wrong dates 
# set unrealistic dates to NA, based on having browsed dates in the previous chunk
# study_data_cleaned <- mutate(study_data_cleaned,
#                            date_of_survey < as.Date("2017-11-01") ~ as.Date(NA), 
#                            date_of_survey == as.Date("2081-01-01") ~ as.Date("2018-01-01"))


# Age group variables ---------------------------------

# make sure age is an integer 
study_data_cleaned <- study_data_cleaned %>% 
  mutate(age_month = as.integer(age_month))

# create an age group variable (combining those over 24 months and those under) 
study_data_cleaned <- study_data_cleaned %>%
  mutate(age_group_bin = factor(
    if_else(age_month >= 24,
      "24-60",
      "0-23"
    )
  ))



## alternatively you could use the age_categories function as below

# create an age group variable by specifying categorical breaks (of years)
# study_data_cleaned <- study_data_cleaned %>% 
#   mutate(age_group = age_categories(age_year, 
#                                     breakers = c(0, 3, 15, 30, 45)
#                                     ))

# create age group variable for under 1 years based on months
study_data_cleaned <- study_data_cleaned %>%
  mutate(age_group = age_categories(study_data_cleaned$age_month,
                                                 breakers = c(6, 12, 24, 36, 48, 60),
                                                 ceiling = TRUE))

## alternatively, create an age group variable specify a sequence
# study_data_cleaned$age_group <- age_categories(study_data_cleaned$age,
#                                              lower = 0, 
#                                              upper = 100, 
#                                              by = 10)

## If you already have an age group variable defined, you should manually
## arrange the categories
# study_data_cleaned$age_group <- factor(study_data_cleaned$age_group,
#                                      c("0-4y", "5-14y", "15-29y", "30-44y", "45+y"))


## to combine different age categories use the following function 
## this prioritises the smaller unit, i.e. if given months and years, will return months first
# study_data_cleaned <- group_age_categories(study_data_cleaned, 
#                                          years = age_group, 
#                                          months = age_group_mon)


# Factor (categorical) variables ---------------------------------

# Change a yes/no variable in to TRUE/FALSE
# create a new variable called consent 
# where the old one is yes place TRUE in the new one
study_data_cleaned <- study_data_cleaned %>% 
  mutate(consent = head_consent == "Yes")

# Change a character to factor - set the levels of a factor 
study_data_cleaned <- study_data_cleaned %>%
  mutate(sex = factor(sex,
                      levels = c("Female", "Male")))

# recode the levels of a factor 
# put these in a second variable called sex_brief
# (this is necessary because the anthro package doesnt accept "Male"/"female")
study_data_cleaned <- study_data_cleaned %>% 
  mutate(sex_brief = recode_factor(sex, 
                             "Female" = "F", 
                             "Male" = "M"))


# change the order of levels
study_data_cleaned <- study_data_cleaned %>% 
  mutate(soap = fct_relevel(soap, 
                            "Distribution", 
                            "Healthcentre", 
                            "Never")
  )


# create a new grouping for soap variable 
# simplified, distribution or health centre then covered otherwise not covered 
study_data_cleaned <- study_data_cleaned %>% 
  mutate(coverage = case_when(
    soap %in% c("Distribution", "Healthcentre") ~ "Covered", 
    TRUE ~ "Not covered")
  )


# explicitly replace NA of a factor
# study_data_cleaned <- study_data_cleaned %>%
#   mutate(coverage = fct_explicit_na(coverage, na_level = "Not Applicable"))


## replace missing values in Dharma multi-choice questions to "" so that we can
## filter them out later.

study_data_cleaned <- study_data_cleaned %>%
  mutate_at(.vars = vars(contains("q53")), # all variables that contain the word "q53"
            .funs = ~factor(replace_na(., "")) # replace all missing values with "" and turn into a factor
            ) 


######## nutrition indicators -------------------------------------------------

# we can use the anthro package to compute z-scores (compared to WHO standards 2006)
# the result is a data.frame with the different indicators and columns
# indicating if they are flagged
# indicators that could not be computed are NA
zscore_results <- with(study_data_cleaned, anthro_zscores(
  sex = as.character(sex_brief),
  age = age_month,
  is_age_in_month = TRUE,
  weight = weight,
  lenhei = height,
  oedema = as.numeric(oedema),
  armc = muac_mm_left_arm / 10 # convert to cm
))


# add columns zscore columns to study dataset
study_data_cleaned <- bind_cols(study_data_cleaned, zscore_results)


# classify child according to weight for height z-scores
# * Global acute malnutrition (GAM): a WHZ score of less than (<) -2 and/or oedema;
# * Moderate acute malnutrition: WHZ score <-2 and â‰¥ -3 and no oedema; 
# * Severe acute malnutrition (SAM): WHZ score <-3 and/or oedema.
study_data_cleaned <- study_data_cleaned %>% 
  mutate(
    gam_whz = zwfl <  -2 | oedema == "Yes", 
    mam_whz = zwfl >= -3 & zwei < -2, 
    sam_whz = zwfl <  -3 | oedema == "Yes"
  ) %>%
  # set flagged children to NA for each of the indicator variables
    # if the flag for this indicator is not missing and is 1 then set indicator vars to NA
    # else leave the indicator variable as it was
  mutate_at(.vars = vars(gam_whz, mam_whz, sam_whz), # select the indicator variables
            .funs = ~if_else(!is.na(fwfl) & fwfl == 1, NA, .)) # NA if flagged, else leave as is



# classify children for stunting according to height for age z-scores
# * Stunting: HAZ score <-2;
# * Moderate stunting: HAZ score >=-3 and <-2; 
# * Severe stunting: HAZ score <-3.
study_data_cleaned <- study_data_cleaned %>% 
  mutate(
    stunting_haz = zlen < -2, 
    moderate_stunting_haz = zlen >= -3 & zlen < -2, 
    severe_stunting_haz = zlen < -3
  ) %>%
  # set flagged children to NA for each of the indicator variables
    # if the flag for this indicator is not missing and is 1 then set indicator vars to NA
    # else leave the indicator variable as it was
  mutate_at(.vars = vars(stunting_haz, 
                         moderate_stunting_haz, 
                         severe_stunting_haz), # select the indicator variables
            .funs = ~if_else(!is.na(flen) & flen == 1, NA, .)) # NA if flagged, else leave as is



# classify children for underweight according to height for age z-scores 
# * Underweight: WAZ score < -2; 
# * moderate underweight: WAZ score >=-3 and <-2; 
# * Severe underweight: WAZ <-3
study_data_cleaned <- study_data_cleaned %>% 
  mutate(
    underweight_waz = zwei < -2 | oedema == "Yes", 
    moderate_underweight_waz = zwei >= -3 & zwei < -2, 
    severe_underweight_waz = zwei < -3 | oedema == "Yes"
  ) %>%
  # set flagged children to NA for each of the indicator variables
    # if the flag for this indicator is not missing and is 1 then set indicator vars to NA
    # else leave the indicator variable as it was
  mutate_at(.vars = vars(underweight_waz, 
                         moderate_underweight_waz, 
                         severe_underweight_waz), # select the indicator variables
            .funs = ~if_else(!is.na(fwei) & fwei == 1, NA, .)) # NA if flagged, else leave as is



# classify children according to muac 
# * Global acute malnutrition (GAM): MUAC of <125mm and/or oedema;
# * Moderate acute malnutrirtion: MUAC <125mm and >= 115mm and no oedema;
# * Severe acute malnutrition (SAM): MUAC <115mm and/or oedema.
study_data_cleaned <- study_data_cleaned %>% 
  mutate(
    gam_muac = muac_mm_left_arm < 125 | oedema == "Yes", 
    mam_muac = muac_mm_left_arm < 125 & muac_mm_left_arm >= 115 & oedema == "No", 
    sam_muac = muac_mm_left_arm < 115 |  oedema == "Yes"
  )


# define all the indicators of interest 
# we will use this to run the same function over all variables later on
indicators <- c("gam_whz",
                "mam_whz",
                "sam_whz",
                 
                "stunting_haz", 
                "moderate_stunting_haz", 
                "severe_stunting_haz", 
                
                "underweight_waz", 
                "moderate_underweight_waz", 
                "severe_underweight_waz",
                
                "gam_muac",
                "mam_muac", 
                "sam_muac"
                )


# turn all indicators in to factors 
study_data_cleaned <- study_data_cleaned %>%
  mutate_at(.vars = vars(indicators), # all variables named in indicators
            .funs = ~factor(.) # turn into a factor
            ) 


# turn all flags in to TRUE/FALSE variables
study_data_cleaned <- study_data_cleaned %>%
  mutate_at(.vars = vars(c("fwei", "flen", "fwfl")), # names of flag variables
            .funs = ~as.logical(.) # turn in to logical
            )


######## weighting ------------------------------------------------------------

study_data_cleaned <- add_weights(x = study_data_cleaned, 
                                  p = population_data_age, 
                                  age_group, sex)

# drop unwanted rows  ---------------------------------------------------------

# you may want to drop rows with missing IDs (i.e. blank rows from excel) 
  # simply add a & !is.na(fact_0_id) if using a dharma dataset
# you will also want to drop those rows with no consent! 
study_data_cleaned <- study_data_cleaned %>%
  filter(consent & 
           age_month > 6 & 
           age_month < 60
           )
```


```{r save_cleaned_data, eval = FALSE}
## OPTIONAL: save your cleaned dataset as an excel file! 
## put the current date in the name so you know!
writexl::write_xlsx(study_data_cleaned, paste0("study_data_cleaned_", Sys.Date(), ".xlsx"))
```



```{r survey_design}
## USE THIS TO SET THE STUDY DESIGN FOR YOUR SURVEY  ---------------------------
##
## This creates "survey objects" which can be used as data frames for calculating
## weighted proportions etc. 
## There are several options for study design here. 
## At the basic level you want to decide if it is a simple random or a cluster
## design study. You will then need to identify your weights variable. 
## You can also create several study designs, e.g. if you would like to have
## an overall design and a stratified design (e.g. by sex or by region). 
##
## Checklist for study design --------------------------------------------------
## 
## - [ ] Make sure you have created all necessary variables in earlier code chunks!!
## - [ ] Decide on your study design (cluster or simple random)
## - [ ] If doing cluster:
##          - [ ] place your cluster ID variable in the ids option 
##                (e.g. householdID - "fact_0_id" not availble in dat dict)
##          - [ ] specify your weight variable (created previously)
##                (set to NULL if want no weights)
## - [ ] If doing simple random: 
##          - [ ] set ids equals 1 to have no clustering 
##          - [ ] specify your weight variable (created previously)
##                (set to NULL if want no weights)
## - [ ] Create additional study designs based on strata if you did stratified 
##        sampling 
##      (make sure that your weight variable is based on appropriately stratified
##        population data)


# simple random sample (using srvyr package)
survey_design <- study_data_cleaned %>% 
  as_survey_design(ids = 1, # 1 for no cluster ids 
                   weights = surv_weight, # weight variable created above 
                   strata = NULL # sampling was simple (no strata)
                   )
```






# Results 



## Demographic information

Compare the proportions in each age group between your sample and the source population. 
This is important to be able to highlight potential sampling bias. 
You could similarly repeat this looking at distributions by sex. 

Note that these p-values are just indicative, and a descriptive discussion (or
visualisation with age-pyramids below) of the distributions in your study sample 
compared to the source population is more
important that the binomial test itself. This is because increasing sample size
will more often than not lead to differences that may be irrelevant after weighting
your data. 


```{r descriptive_sampling_bias}
# first the counts and props of the study population
ag <- descriptive(study_data_cleaned, "age_group") %>%
  mutate(n_total = sum(n))

# then the counts and props of the source population
propcount <- group_by(population_data_age, age_group) %>%
    tally(population) %>%
    mutate(prop = n / sum(n))

# bind together the columns of two tables, group by age, and perform a 
# binomial test to see if n/total is significantly different from population
# proportion.
  # suffix here adds to text to the end of columns in each of the two datasets
left_join(ag, propcount, by = "age_group", suffix = c("", "_pop")) %>%
  group_by(age_group) %>%

  # broom::tidy(binom.test()) makes a data frame out of the binomial test and
  # will add the variables p.value, parameter, conf.low, conf.high, method, and
  # alternative. We will only use p.value here. You can include other
  # columns if you want to report confidence intervals
  mutate(binom = list(broom::tidy(binom.test(n, n_total, prop_pop)))) %>%
  unnest() %>% # important for expanding the binom.test data frame
  mutate(prop_pop = prop_pop * 100) %>%

  # Adjusting the p-values to correct for false positives 
  # (because testing multiple age groups). This will only make 
  # a difference if you have many age categories
  mutate(p.value = p.adjust(p.value, method = "holm")) %>%
  select(age_group, n, prop, n_pop, prop_pop, p.value) %>%
                      
  # Only show p-values over 0.001 (those under report as <0.001)
  mutate(p.value = if_else(p.value < 0.001, "<0.001", as.character(round(p.value, 3)))) %>%

  # rename the columns appropriatley
  rename(
    "Age group" = age_group,
    "Study population (n)" = n,
    "%" = prop,
    "Source population (n)" = n_pop,
    "%" = prop_pop,
    "P-value" = p.value
  ) %>%
  kable(digits = 2)

```



```{r median_age_sex_ratios}
# compute the median age 
medage <- median(study_data_cleaned$age_month)

# paste the lower and uper quartile together
iqr <- paste0(  # basically copy paste togehter the following
  # calculate the 25% and 75% of distribution, with missings removed
  quantile(     
    study_data_cleaned$age_month, 
    c(0.25, 0.75), 
    na.rm = TRUE), 
  # between lower and upper place a dash
  collapse = "-")

# compute overall sex ratio 
sex_ratio <- study_data_cleaned %>% 
  count(sex) %>% 
  spread(sex, n) %>%
  mutate(ratio = round(Male/Female, digits = 3)) %>%
  pull(ratio)

# compute sex ratios by age group 
sex_ratio_age <- study_data_cleaned %>% 
  count(age_group, sex) %>% 
  spread(sex, n) %>%
  mutate(ratio = round(Male/Female, digits = 3)) %>%
  select(age_group, ratio)

# sort table by ascending ratio then select the lowest (first)
min_sex_ratio_age <- arrange(sex_ratio_age, ratio) %>% slice(1)
```


Among the `r nrow(study_data_cleaned)` surveyed individuals, there were 
`r fmt_count(study_data_cleaned, sex == "Female")` females and 
`r fmt_count(study_data_cleaned, sex == "Male")` males (unweighted). The male to
female ratio was `r sex_ratio` in the surveyed population. The lowest male to
female ratio was `r min_sex_ratio_age$ratio`
in the `r min_sex_ratio_age$age_group` month age group.
The median age of surveyed individuals was `r medage` years (Q1-Q3 of `r iqr`
years). Children under two years of age made up 
`r fmt_count(study_data_cleaned, age_group_bin == "0-23")`of the surveyed individuals.
The highest number of surveyed indivduals (unweighted) were in the 
`r descriptive(study_data_cleaned, "age_group") %>% slice(which.max(n)) %>% pull(age_group)` 
year age group.



```{r cluster_hh_size}
# get counts of the number of households per cluster
clustersize <- study_data_cleaned %>% 
  count(cluster_number) 

# get the median number of households per cluster
clustermed <- clustersize %>% 
  summarise(median(n))

# get the min and max number of households per cluster
# paste these together seperated by a dash 
clusterrange <- paste0(range(clustersize$n), collapse = "-")

# get counts of children per household 
# do this by cluster as household IDs are only unique within clusters
hhsize <- study_data_cleaned %>% 
  group_by(cluster_number) %>% 
  count(household_id) 

# get median number of children per household
# ungroup to give you the overall median 
hhmed <- hhsize %>%
  ungroup() %>% 
  summarise(median(n))

# get the min and max number of children per household
# paste these together seperated by a dash 
hhrange <- paste0(
  range(hhsize$n), 
  collapse = "-")
  
```


The median number of households per cluster was
`r clustermed`, with a range of `r clusterrange`. The median number of children
per household was `r hhmed` and the range was `r hhrange`. 

Age distribution of household population by year age group and gender.

```{r describe_by_age_group_and_sex}

# return counts and proportions of individuals by age and sex
# note that proportions are of the total sample (not within each gender) 
  # to change this, set proptotal = FALSE
descriptive(study_data_cleaned, 
            "age_group", 
            "sex", 
            rowtotals = TRUE, 
            coltotals = TRUE, proptotal = TRUE) %>% 
  # rename column names appropriately
  rename("Age" = age_group, 
         "Female cases (n)" = Female_n, 
         "%" = Female_prop, 
         "Male cases (n)" = Male_n, 
         "%" = Male_prop) %>% 
  kable(digits = 2)
```


There were `r fmt_count(study_data_cleaned, is.na(sex))` cases missing information on sex and 
`r fmt_count(study_data_cleaned, is.na(age_group))` missing age group.

Age and gender distribution of household population covered by the survey.

```{r age_pyramid, warning=FALSE}
# This is unweighted as you are using study_data_cleaned
plot_age_pyramid(study_data_cleaned, 
                 age_group = "age_group", 
                 split_by = "sex",
                 proportion = TRUE) + 
  labs(y = "Proportion", x = "Age group (months)") +                 # change axis labels
  theme(legend.position = "bottom",     # move legend to bottom
        legend.title = element_blank(), # remove title
        text = element_text(size = 18)  # change text size
       )
```

Weighted age and gender distribution - if this is substantially different to your unweighted 
pyramid, then it may suggest some sampling bias (similarly to the table comparing 
sample and source population distributions by binomial test). 

```{r age_pyramid_survey, warning=FALSE}
# Note that here you are using survey_design so will produce weighted proportions
plot_age_pyramid(survey_design,
                 age_group = "age_group",
                 split_by = "sex", 
                 proportion = TRUE) +
  labs(y = "Proportion", x = "Age group (months)") +                 # change axis labels
  theme(legend.position = "bottom",     # move legend to bottom
        legend.title = element_blank(), # remove title
        text = element_text(size = 18)  # change text size
       )
```


## Quality of indicators collected

You may want to look at the standard deviation of your zscores using box-plots. 
This will also help you to assess how reliable your survey sample is. 
A wide distribution may suggest an unreliable survey sample. 
Standard deviations are expected to be higher in younger age groups as it can 
be harder to measure babies. 
There is some suggestion that deviation may be higher in boys due to a higher 
rate of pre-term births. But generally these should not be substantially different. 

```{r boxplot_indicators}
# pull variables together for plotting 
temp_data <- study_data_cleaned %>%
  # stack variable names in one column and values for vars in another
  # call first column indicator and second column zscore
  gather("Indicator", "Zscore", zwfl, zlen, zwei) %>% 
  # only keep variables of interest
  select(Indicator, Zscore) %>% 
  # rename indicators to something more understandable
  mutate(
    Indicator = recode_factor(Indicator, 
    "zlen" = "HAZ", 
    "zwei" = "WAZ", 
    "zwfl" = "WHZ" 
  ))


# use indicators on the x-axis and z-score on the y-axis
ggplot(temp_data, aes(x = Indicator, y = Zscore)) + 
  # plot as a box plot
  geom_boxplot() + 
  # add a dotted horizontal line at 0 for reference 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  # change theme to white background with black axes
  theme_classic()

```


Box plot of Zscores for height-for-age, weight-for-age and weight-for-height by sex

```{r boxplot_indicators_sex}

# pull variables together for plotting 
temp_data <- study_data_cleaned %>%
  # stack variable names in one column and values for vars in another
  # call first column indicator and second column zscore
  gather("Indicator", "Zscore", zwfl, zlen, zwei) %>% 
  # only keep variables of interest
  select(sex, Indicator, Zscore) %>% 
  # rename indicators to something more understandable
  mutate(
    Indicator = recode_factor(Indicator, 
    "zlen" = "HAZ", 
    "zwei" = "WAZ", 
    "zwfl" = "WHZ" 
  ))

# use indicators on the x-axis and z-score on the y-axis
# colour according to sex 
ggplot(temp_data, aes(x = Indicator, y = Zscore, fill = sex)) + 
  # plot as a boxplot
  geom_boxplot() + 
  # add a dotted horizontal line at 0 for reference 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  # remove the title of legend 
  theme(legend.title = element_blank()) + 
  # change theme to white background with black axes
  theme_classic()
```


Box plot of Zscores for height-for-age by age group

```{r boxplot_haz_age}

# use age group on the x-axis and  height z-score  on the y-axis
ggplot(study_data_cleaned, aes(x = age_group, y = zlen)) + 
  # plot as a boxplot
  geom_boxplot() + 
  # add a dotted horizontal line at 0 for reference 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  # change axis titles 
  labs(x = "Age group (Months)", y = "HAZ score") + 
  # change theme to white background with black axes
  theme_classic()

```

Box plot of Zscores for weight-for-age by age group

```{r boxplot_waz_age}

# use age group on the x-axis and  weight z-score  on the y-axis
ggplot(study_data_cleaned, aes(x = age_group, y = zwei)) + 
  # plot as a boxplot
  geom_boxplot() + 
  # add a dotted horizontal line at 0 for reference 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  # change axis titles 
  labs(x = "Age group (Months)", y = "WAZ score") + 
  # change theme to white background with black axes
  theme_classic()

```


Box plot of Zscores for weight-for-height by age group

```{r boxplot_whz_age}

# use age group on the x-axis and  weight-height z-score  on the y-axis
ggplot(study_data_cleaned, aes(x = age_group, y = zwfl)) + 
  # plot as a boxplot
  geom_boxplot() + 
  # add a dotted horizontal line at 0 for reference 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  # change axis titles 
  labs(x = "Age group (Months)", y = "WHZ score") + 
  # change theme to white background with black axes
  theme_classic()

```


You can then also plot your zscores in comparison to the WHO reference population. 
While the observed scores will not to match the reference scores, the hope is 
that they are somewhat normally distributed. 
Z-curve of height-for-age among non-flagged children for this indicator
```{r zcurve_haz}

# use unweighted dataset 
study_data_cleaned %>% 
  # only consider z-scores that are not flagged
  filter(flen == FALSE) %>% 
  # plot zcurve
  zcurve(zlen) + 
  # change theme to white background with black axes
  theme_classic()

```


Z-curve of weight-for-age among non-flagged children for this indicator
```{r zcurve_waz}

# use unweighted dataset 
study_data_cleaned %>% 
  # only consider z-scores that are not flagged
  filter(fwei == FALSE) %>% 
  # plot zcurve
  zcurve(zwei) + 
  # change theme to white background with black axes
  theme_classic()

```


Z-curve of weight-for-height among non-flagged children for this indicator
```{r zcurve_whz}

# use unweighted dataset 
study_data_cleaned %>% 
  # only consider z-scores that are not flagged
  filter(fwfl == FALSE) %>% 
  # plot zcurve
  zcurve(zwfl) + 
  # change theme to white background with black axes
  theme_classic()

```


You will also want to look at the number of children missing indicator measures, 
as well as the number of flagged by indicator. 
In addition the number of children missing MUAC was `r fmt_count(study_data_cleaned, is.na(muac_mm_left_arm))`. 

```{r missing_flagged_indicators}

study_data_cleaned %>% 
  multi_descriptive(flen, fwei, fwfl, .id = "Indicator") %>% 
  # re-order columns (drop total_prop too)
  select(Indicator, Missing_n, Missing_prop, TRUE_n, TRUE_prop, FALSE_n, FALSE_prop, Total_n) %>%
  
  # rename indicators to something more understandable
  mutate(
    Indicator = recode_factor(Indicator, 
    "flen" = "HAZ", 
    "fwei" = "WAZ", 
    "fwfl" = "WHZ" 
  )) %>% 
  
  # rename total column to have a capital N in brackets
  rename("Total (N)" = Total_n) %>% 
  # swap variabales with props in for percentages 
  rename_redundant("prop" = "%") %>%
  # swap TRUEs for Flagged and FALSE for included
  # put n's in brackets
  augment_redundant("TRUE" = "Flagged",
                    "FALSE" = "Included",
                    "_n$" = " (n)") 

```


## Nutritional status based on indicators  

Prevalence of malnutrition based on MUAC, by age group (months) and overall 

```{r muac_age_group}

overall <- survey_design %>% 
  # tabulate multiple variables with same values
  # indicators[10:12] has the names of muac variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to indicators as columns 
  # important to drop missings! use na.rm = TRUE)
  tabulate_binary_survey(indicators[10:12], keep = TRUE, 
                         transpose = "variable", na.rm = TRUE) %>% 
  # add in an age_group variable to be able to bind to age_group table below 
  mutate(age_group = "Overall") %>% 
  # reorganise columns so can bind to age_group table below 
  select(age_group, 1:6)



age_strat <- survey_design %>% 
  # tabulate multiple variables with same values
  # indicators[10:12] has the names of muac variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to have age groups as rows
  tabulate_binary_survey(indicators[10:12], strata = age_group, keep = TRUE,
                         transpose = "variable", na.rm = TRUE) 

# bind the age stratified and overall tables together 
bind_rows(age_strat, overall) %>% 
  # change column names 
  rename("Age group (months)" = "age_group", 
         "GAM (n)" = "gam_muac n", 
         "Proportion (95%CI)" = "gam_muac ci", 
         "MAM (n)" = "mam_muac n", 
         "Proportion (95%CI)" = "mam_muac ci", 
         "SAM (n)" = "sam_muac n", 
         "Proportion (95%CI)" = "sam_muac ci") %>% 
  knitr::kable(digits = 1)

  

```



You could add a filter argument to this to only look at children <87cm for example. 



Prevalence of malnutrition based on MUAC among children <87cm, by age group (months) and overall 

```{r muac_filter_age_group}

overall <- survey_design %>% 
  filter(height < 87) %>% 
  # tabulate multiple variables with same values
  # indicators[10:12] has the names of muac variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to indicators as columns 
  # important to drop missings! use na.rm = TRUE)
  tabulate_binary_survey(indicators[10:12], keep = TRUE, 
                         transpose = "variable", na.rm = TRUE) %>% 
  # add in an age_group variable to be able to bind to age_group table below 
  mutate(age_group = "Overall") %>% 
  # reorganise columns so can bind to age_group table below 
  select(age_group, 1:6)



age_strat <- survey_design %>% 
  filter(height < 87) %>% 
  # tabulate multiple variables with same values
  # indicators[10:12] has the names of muac variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to have age groups as rows
  tabulate_binary_survey(indicators[10:12], strata = age_group, keep = TRUE,
                         transpose = "variable", na.rm = TRUE) 

# bind the age stratified and overall tables together 
bind_rows(age_strat, overall) %>% 
  # change column names 
  rename("Age group (months)" = "age_group", 
         "GAM (n)" = "gam_muac n", 
         "Proportion (95%CI)" = "gam_muac ci", 
         "MAM (n)" = "mam_muac n", 
         "Proportion (95%CI)" = "mam_muac ci", 
         "SAM (n)" = "sam_muac n", 
         "Proportion (95%CI)" = "sam_muac ci") %>% 
  knitr::kable(digits = 1)

  

```







Prevalence of malnutrition based on height-for-age z-score categories, by age group (months) and overall


```{r haz_age_group}

overall <- survey_design %>% 
  # tabulate multiple variables with same values
  # indicators[10:12] has the names of muac variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to indicators as columns 
  # important to drop missings! use na.rm = TRUE)
  tabulate_binary_survey(indicators[4:6], keep = TRUE, 
                         transpose = "variable", na.rm = TRUE) %>% 
  # add in an age_group variable to be able to bind to age_group table below 
  mutate(age_group = "Overall") %>% 
  # reorganise columns so can bind to age_group table below 
  select(age_group, 1:6)

age_strat <- survey_design %>% 
  # tabulate multiple variables with same values
  # indicators has the names of indicator variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to have age groups as rows
  tabulate_binary_survey(indicators[4:6], strata = age_group, keep = TRUE,
                         transpose = "variable", na.rm = TRUE) 

# bind the age stratified and overall tables together 
bind_rows(age_strat, overall) %>% 
  # change column names 
  rename("Age group (months)" = "age_group", 
         "Moderate stunting (n)" = "moderate_stunting_haz n", 
         "Proportion (95%CI)" = "moderate_stunting_haz ci", 
         "Severe stunting (n)" = "severe_stunting_haz n", 
         "Proportion (95%CI)" = "severe_stunting_haz ci", 
         "Stunting (n)" = "stunting_haz n", 
         "Proportion (95%CI)" = "stunting_haz ci") %>% 
  knitr::kable(digits = 1)


```


Prevalence of malnutrition based on weight-for-age z-score categories, by age group (months) and overall

```{r waz_age_group}

overall <- survey_design %>% 
  # tabulate multiple variables with same values
  # indicatorshas the names of indicator variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to indicators as columns 
  # important to drop missings! use na.rm = TRUE)
  tabulate_binary_survey(indicators[7:9], keep = TRUE, 
                         transpose = "variable", na.rm = TRUE) %>% 
  # add in an age_group variable to be able to bind to age_group table below 
  mutate(age_group = "Overall") %>% 
  # reorganise columns so can bind to age_group table below 
  select(age_group, 1:6)

age_strat <- survey_design %>% 
  # tabulate multiple variables with same values
  # indicators has the names of indicator variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to have age groups as rows
  tabulate_binary_survey(indicators[7:9], strata = age_group, keep = TRUE,
                         transpose = "variable", na.rm = TRUE)

# bind the age stratified and overall tables together 
bind_rows(age_strat, overall) %>% 
  # change column names 
  rename("Age group (months)" = "age_group", 
         "Moderate underweight (n)" = "moderate_underweight_waz n", 
         "Proportion (95%CI)" = "moderate_underweight_waz ci", 
         "Severe underweight (n)" = "severe_underweight_waz n", 
         "Proportion (95%CI)" = "severe_underweight_waz ci", 
         "Underweight (n)" = "underweight_waz n", 
         "Proportion (95%CI)" = "underweight_waz ci" ) %>% 
  knitr::kable(digits = 1)


```




Prevalence of malnutrition based on weight-for-height z-score categories, by age group (months) and overall

```{r whz_age_group}

overall <- survey_design %>% 
  # tabulate multiple variables with same values
  # indicatorshas the names of indicator variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to indicators as columns 
  # important to drop missings! use na.rm = TRUE)
  tabulate_binary_survey(indicators[1:3], keep = TRUE, 
                         transpose = "variable", na.rm = TRUE) %>% 
  # add in an age_group variable to be able to bind to age_group table below 
  mutate(age_group = "Overall") %>% 
  # reorganise columns so can bind to age_group table below 
  select(age_group, 1:6)

age_strat <- survey_design %>% 
  # tabulate multiple variables with same values
  # indicators has the names of indicator variables in it 
  # keep will drop all rows in the output where the value is not "TRUE"
  # transpose flips the table to have age groups as rows
  tabulate_binary_survey(indicators[1:3], strata = age_group, keep = TRUE,
                         transpose = "variable", na.rm = TRUE) 

# bind the age stratified and overall tables together 
bind_rows(age_strat, overall) %>% 
  # change column names 
  rename("Age group (months)" = "age_group", 
         "GAM (n)" = "gam_whz n", 
         "Proportion (95%CI)" = "gam_whz ci", 
         "MAM (n)" = "mam_whz n", 
         "Proportion (95%CI)" = "mam_whz ci", 
         "SAM (n)" = "sam_whz n", 
         "Proportion (95%CI)" = "sam_whz ci") %>% 
  knitr::kable(digits = 1)


```











######################### DIRKS CODE ########################################################




# Results



## Anthropometric results (based on WHO standards 2006)

```{r}
# we can use the anthro package to compute z-scores
zscore_results <- with(study_data_cleaned, anthro_zscores(
  sex = as.character(sex_brief),
  age = age_month,
  is_age_in_month = TRUE,
  weight = weight,
  lenhei = height,
  oedema = as.numeric(oedema),
  armc = muac_mm_left_arm / 10 # convert to cm
))


# the result is a data.frame with the different indicators and columns
# indicating if they are flagged
# indicators that could not be computed are NA


# below is with weighting considered as well
dirk_results <- with(study_data_cleaned, anthro_prevalence(
  sex = as.character(sex_brief),
  age = age_month,
  is_age_in_month = TRUE,
  weight = weight,
  lenhei = height,
  oedema = as.numeric(oedema),
  armc = muac_mm_left_arm / 10, # convert to cm
  sw = surv_weight
))


# exclude those that are missing gam_whz and those flagged (WHO excludes those certain z score number away)
survey_design %>%
  filter(fwfl == 0 & !is.na(sam_whz)) %>%
  tabulate_binary_survey(indicators[1:3], keep = TRUE)


```




### Design effects and excluded individuals

```{r}
# TODO
```


### Programme coverage

```{r}
# TODO
```


