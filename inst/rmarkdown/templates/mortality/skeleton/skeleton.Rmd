---
title: "Mortality survey"
output: word_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      error = TRUE)
library(dplyr)
library(tidyr)
library(knitr)
library(sitrep)
library(survey) # for survey functions 
library(srvyr) # dplyr wrapper for survey
library(ggplot2)
```




```{r read_data_generic, message = FALSE}

## This section gives a variety of options for reading in datasets in different formats

## Read data ------------------------------------
# CSV file
# linelist_raw <- rio::import("linelist.csv")
#
# Excel file
# to read in a specific sheet use "which"
# linelist_raw <- rio::import("linelist.xlsx", which = "Sheet1")
#
# Stata data file
# linelist_raw <- rio::import("linelist.dat")
#
# For password protected Excel file 
# use the excel.link package 
# library(excel.link)
# linelist_raw <- excel.link::xl.read.file("linelist.xlsx",
#                                          xl.sheet = "Sheet1",
#                                          password = askpass::askpass(prompt = "please enter file
#                                                                      password"))

```




```{r read_dharma_excel_data, message = FALSE}

# If your linelist is an excel export of data from Dharma use this code chunk
# If that is not the case use the code chunk above reading in other formats

## Read data ------------------------------------------------------

# This assums that you have two levels in your survey (level 0 and level 1). 
# These correspond to, for example, household and individual. 
# We will read in and later merge these two levels in to one dataset. 
# We will assume the data is not password protected (code for reading 
# password protected excels is in the read_data_generic code chunk)

## read in household data sheet
# study_data_hh <- rio::import("mortality_survey.xlsx", 
#                               which = "Level 0 Named")

## read in individual level data sheet
# study_data_indiv <- rio::import("mortality_survey.xlsx", 
#                               which = "Level 1 Named")

## DELETE THIS LINE --- YOU READ IN YOUR OWN DATA ABOVE!
# generates a fake dataset for use as an example in this template
study_data_raw <- gen_data(dictionary = "Mortality", 
                         varnames = "column_name",
                         numcases = 1000)

## Data dictionary ---------------
## The data dictionary has variable names in the "column_name" column.
## Possible values for variables are specified in the "choice_code" and "choice_name"
## columns. 
## Where code has the shortened values and name has the full text values.

# read in data dictionary (for reference purposes)
# study_data_dict <- import("mortality_survey.xlsx",
#                       which = "Data Dictionary")

## you can look at the dictionary by uncommenting the line below
# View(study_data_dict) 

## you can view variable names in the data dicationry uncommenting the line below
# study_data_dict$column_name

## DELETE THIS LINE --- YOU READ IN YOUR OWN DATA ABOVE!
# generates a fake dataset for use as an example in this template
# this dataset already has the two levels merged
# variable names are in the column_name column
# possible values for each variable are specified in the "Code" columns.
study_data_dict <- msf_survey_dict("Mortality")
```


```{r merge_data_levels}

## Need to merge individual data with household data
## This is done using a unique identifier for the household 
## (which repeats in the individuals dataset) 
## For a Dharma dataset this variable is "fact_0_id"

## fact_0_id, the merging variable, needs to be applied to all relevant rows in the indidivual data set
## (equivalent of dragging down with mouse in excel)
## this is achieved using the fill function from the tidyr package
# study_data_indiv <- study_data_indiv %>%
#                       fill(fact_0_id)

## join the individual and household data to form a complete data set
#study_data_raw <- left_join(study_data_hh, study_data_indiv, by = "fact_0_id")
```




```{r read_population_data, warning = FALSE, message = FALSE}

## There are two options for using population data here. 
## The first one is where you only know the total population number, and the 
## proportion breakdown for categories (e.g. by age group, sex or region). 
## The second option is to read in population from excel. 
## In both cases you will need to make sure that the respective groups for 
## population fit the groups in your linelist data set!
##
## Checklist for population data ----------------------------------------------
## 
## - [ ] Decide if you have stratified population data available as counts or only proportions
## - [ ] If you have counts available:
##          - [ ] use View on the fake data generated to make sure your format in excel matches
##          - [ ] read in and clean data appropriately in the "Read data" section
##          - [ ] make sure the groups match the appropriate variable in your linelist!
## - [ ] If have total population and proportion breakdown available: 
##          - [ ] use the gen_population function in "counts from populaiton proportions" section
##          - [ ] type in your population, groups, and respective proportions
##          - [ ] group can be any categorical variable you want
##          - [ ] make sure the groups match the appropriate variable in your linelist!
## - [ ] DELETE OR COMMENT OUT THE UNUSED SECTION


## Read data ------------------------------------

## Excel file
## See the gen_population function section below to see how to structure your data!!
## to read in a specific sheet use "which"
# population_data <- rio::import("population.xlsx", which = "Sheet1")

## repeat same cleaning steps as in standardise_clean_data code chunk as appropriate
## make sure your place variable name matches!

## Counts from population proportions ------------------------------------ 
## if you only know the total population and the proportions in each age group, use this function 


# generate population data by age groups in years 
population_data_age <- gen_population(total_pop = 10000, # set the total population 
  groups = c("0-4", "5-14", "15-29", "30-44", "45+"),    # set the groups
  proportions = c(0.182, 0.278, 0.26, 0.11, 0.07),       # set the proportions for each group
  strata = c("Male", "Female")) %>%                      # stratify by gender 
  rename(age_group = groups,                             # rename columns (syntax is NEW NAME = OLD NAME)
         sex = strata,
         population = n)
```

```{r standardise_clean_data}

## All your data cleaning and new variable creation should happen in this chunk. 
## This way, if you mess up all you have to do is push the small arrow at the
## top of this chunk between the cogg and the play buttons, to run all the 
## code chunks up to the current one, then continue your cleaning from where you
## started. 
## 
## YOU WILL NEED TO ADAPT THIS SECTION ACCORDING TO YOUR DATA!
## 
## currently there are examples of cleaning for: 
##    - Date variables 
##    - Numeric variables 
##    - Categorical variables from numerics (e.g. age groups) 
##    - Factor variables (for creating/manipulating categorical variables)
##    - Dropping rows and columns 



# Date variables ---------------------------------
# IF YOU ARE USING THE DATA DICTIONARY USE THIS OTHERWISE UNCOMMENT LINES BELOW
# make sure all date variables are formatted as dates 
DATEVARS <- filter(linelist_dict, data_element_valuetype == "DATE") %>% 
  select(data_element_shortname) # select date vars
# change to dates 
linelist_cleaned <- linelist_cleaned %>%
  mutate_at(DATEVARS$data_element_shortname, as.Date)

# if you dont have a data dictionary you could do it this way too
# linelist_cleaned <- linelist_cleaned %>%
#   mutate_at(vars(matches("date|Date")), as.Date)

# set unrealistic dates to NA, based on having browsed dates in the previous chunk
# linelist_cleaned <- mutate(linelist_cleaned,
#                            date_of_onset < as.Date("2017-11-01") ~ NA, 
#                            date_of_onset == as.Date("2081-01-01") ~ as.Date("2018-01-01"))
  



study_data_cleaned <- study_data_raw %>%
  # some cleaning
  mutate(age_in_years = as.integer(q155_q5_age_year),
         age_group = age_categories(age_in_years, breakers = c(0, 5, 15, 30, 45)),
         sex = q4_q6_sex,
         died = q136_q34_died == "Yes",
         cause_of_death = factor(q138_q36_died_cause,
                                 levels = c("Malaria/fever", "Diarrhoea", "Respiratory",
                                            "Trauma/accident", "Pregnancy-related", 
                                            "Violence", "Outbreak disease (specify)", 
                                            "Malnutrition", "Unknown", "Other (specify)")))



study_data_cleaned <- study_data_cleaned %>%
  filter(!is.na(sex))


```



```{r weights_person_days}

######## WEIGHTING ------------------------------------------------------------

study_data_cleaned <- add_weights(study_data_cleaned, population_data_age, age_group, sex)

#### OBSERVATION DAYS ----------------------------------------------------------

## define start and end of your recall period

# set the start of your recall-period
recall_start <- as.Date("2018-01-01")

# set the end of your recall period (when your survey stopped) 
recall_end <- as.Date("2018-05-01")


## define start date 
## this is either the begining of your recall period (which you define in advance)
## or a date after the start of recal if applicable (e.g. arrivals or births)


# choose earliest appropriate date entered in survey
# from camp arrival, household arrival and born date (pmin) or the start of study period (pmax)
study_data_cleaned <- study_data_cleaned %>%
  mutate(startdate = pmax(
    pmin(q114_q16_date_arrival_camp,
          q41_q25_hh_arrive_date,
          q88_q33_born_date, na.rm = TRUE),
    recall_start, na.rm = FALSE
  ))

# TO DO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# find which column had the minimum value 
# (using names and which.min - but cant figure out with dplyr) - have an ugly base R solution




## define end date 
## this is either the end of your recall period 
## or a date before the end of recall if applicable (e.g. departures, deaths)

# choose earliest date entered in survey
# from camp departures, death and end of the study
study_data_cleaned <- study_data_cleaned %>% 
  mutate(enddate = pmin(q45_q29_hh_leave_date, 
                         q137_q35_died_date,
                         recall_end, na.rm = TRUE))


# TO DO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# find which column had the minimum value 
# (using names and which.min - but cant figure out with dplyr) - have an ugly base R solution


## Define observation time in days (need to fix negatives in gen_data)
study_data_cleaned <- study_data_cleaned %>% 
  mutate(obstime = as.numeric(enddate - startdate))

# c(study_data_cleaned[53, c("q114_q16_date_arrival_camp", "q41_q25_hh_arrive_date", "q88_q33_born_date", "q45_q29_hh_leave_date", "q137_q35_died_date")])
```




```{r survey_design}
## USE THIS TO SET THE STUDY DESIGN FOR YOUR SURVEY  ---------------------------
##
## This creates "survey objects" which can be used as data frames for calculating
## weighted proportions etc. 
## There are several options for study design here. 
## At the basic level you want to decide if it is a simple random or a cluster
## design study. You will then need to identify your weights variable. 
## You can also create several study designs, e.g. if you would like to have
## an overall design and a stratified design (e.g. by sex or by region). 
##
## Checklist for study design --------------------------------------------------
## 
## - [ ] Make sure you have created all necessary variables in earlier code chunks!!
## - [ ] Decide on your study design (cluster or simple random)
## - [ ] If doing cluster:
##          - [ ] place your cluster ID variable in the ids option 
##                (e.g. householdID - "fact_0_id" not availble in dat dict)
##          - [ ] specify your weight variable (created previously)
##                (set to NULL if want no weights)
## - [ ] If doing simple random: 
##          - [ ] set ids equals 1 to have no clustering 
##          - [ ] specify your weight variable (created previously)
##                (set to NULL if want no weights)
## - [ ] Create additional study designs based on strata 
##      (make sure that your weight variable is based on appropriately stratified
##        population data)


# simple random sample (using srvyr package)
survey_design <- study_data_cleaned %>% 
  as_survey_design(ids = 1, # 1 for no cluster ids 
                   weights = weight # weight variable created above 
                   )


# simple random sample stratified by sex 
survey_design_sex <- study_data_cleaned %>% 
  as_survey_design(ids = 1, # 1 for no cluster ids 
                   weights = weight, # weight variable created above 
                   strata = sex
                   )
```





# Introduction

# Methods

## Study Design 

## Sample Size and Sampling methods

### Sample Size

### Sampling

#### Random sampling

```{r}
# Insert some code to generate a random number sequence
```

#### Cluster sampling

```{r}
# Insert some example code to do cluster sampling
```

## Data collection

## Data analysis
<!-- TODO: add paragraph about R/sitrep -->

# Results

```{r}
# TODO: Arrivals and departures of included household members during the recall period;
```


## Demographic information

```{r}
# add descriptive table with unweighted counts for different stuff
```

TODO: add some sample text with inline R

Age distribution of current household population by five year age groups, dependency age groups, and by child and adult populations, by gender.
```{r describe_by_age_group_and_sex}
descriptive(study_data_cleaned, 
            "age_group", 
            "sex", 
            rowtotals = TRUE, 
            coltotals = TRUE, proptotal = TRUE) %>% 
  rename("Age" = age_group, 
         "Female cases (n)" = Female_n, 
         "%" = Female_prop, 
         "Male cases (n)" = Male_n, 
         "%" = Male_prop) %>% 
  kable(digits = 2)
```


Age and gender distribution of household population covered by the survey.
```{r age_pyramid}
plot_age_pyramid(study_data_cleaned, 
                 age_group = "age_group", 
                 split_by = "sex",
                 proportion = TRUE) + 
  labs(y = "Proportion", x = "Age group (years)") +                    # change axis labels
  theme(legend.position = "bottom", legend.title = element_blank())   # remove title and move legend
```

Weighted age distribution - if this is substantially different to your unweighted 
pyramid, then it may suggest some sampling bias. 
```{r age_pyramid_survey}
plot_age_pyramid(survey_design_sex,
                 age_group = "age_group",
                 split_by = "sex", 
                 proportion = TRUE) +
  labs(y = "Proportion", x = "Age group (years)") +                    # change axis labels
  theme(legend.position = "bottom", legend.title = element_blank())   # remove title and move legend
```


## Mortality

Reported causes of death and cause-specific mortality rates, weighted

```{r}

# you will get an extra column, for weighted counts, weighted % with CI, and mortality per 10,000 persons/day with CI
cause_of_death_prop <- survey_design %>% 
  group_by(cause_of_death) %>% 
  summarize(n = survey_total(vartype = "se", na.rm = TRUE),
            proportion = survey_mean(vartype = "ci", na.rm = TRUE)
            ) %>% 
  mutate(n = round(n)) %>% 
  select(-n_se)

cause_of_death_mort <- survey_design %>% 
  group_by(cause_of_death) %>% 
  summarize( mortality = survey_ratio(as.numeric(died) * 10000, obstime, vartype = "ci")) 

dplyr::left_join(cause_of_death_prop, cause_of_death_mort) %>% 
  unite_ci("% (95% CI)", starts_with("proportion"), m100 = TRUE, percent = FALSE, digits = 1) %>%
  unite_ci("Mortality per 10,000 persons/day (95% CI)", starts_with("mortality"), m100 = FALSE, percent = FALSE) %>%
  kable()


```

Reported causes of death and cause-specific mortality rates, by age, weighted
```{r}

survey_design %>% 
  tabulate_survey(cause_of_death, age_group) %>%
  kable()

```

Reported causes of death and cause-specific mortality rates, by gender, weighted
```{r}
survey_design %>% 
  tabulate_survey(cause_of_death, sex) %>%
  kable()

```

## Morbidity

```{r}
# symptoms
```

# Conclusions

# Recommendations

# References

