---
title: "Cholera outbreak report"
output: word_document
---

# Introduction to this template

This is a template which can be used to create an automated outbreak situation
report for cholera. 

- It is organised by time, place and person. 
- You can type normal text in white spaces (such as here) and r-code in grey
    spaces (denoted by three backticks and r) (see [Rmarkdown
    introduction](https://rmarkdown.rstudio.com/articles_intro.html) and
    [Markdown basics](https://rmarkdown.rstudio.com/authoring_basics.html))
- Introductions and contents of sections are within square brackets "[...]" and
    can be deleted as appropriate
- Examples of inline code (to automate updating numbers, e.g. in the "Person section"), can
    similarly be removed/updated
- Code itself can be deleted, but as a word of caution: make sure you aren't
    deleting bits where variables are created/manipulated, or at least update
    them appropriatley
- For a more detailed exaplanation of this template, see [Wiki](https://github.com/R4EPI/sitrep/wiki)
- ADD LIST ON WHICH PACKAGES WILL BE USED FOR WHAT REASONS! AND HOW TO INSTALL
- OTHER INFO TO ADD??


```{r setup, include=FALSE}
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = FALSE, error = TRUE, fig.width = 6*1.25, fig.height = 6)
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")


library(knitr) # for creating output doc
library(dplyr) # for cleaning/shaping data
library(ggplot2) # for plotting diagrams

# epi packages
library(sitrep) # for msf field epi functions
library(incidence) # for epicurves
library(ISOweek) # for creating epiweeks
library(epitools) # for creating 2by2 tables

# spatial packages
library(sf)
library(ggspatial)

# set default text size to 16 for plots
# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))
```




```{r read_DHIS_excel_data}

# If your linelist is an excel export of data from DHIS2 use this code chunk
# This assumes your data fits the standardised MSF data dictionary for this
# disease (Otherwise use one of the code chunks below for csv DHIS data and for
# non DHIS data)


## Read data ------------------------------------------------------

# USE ONE OF THE BELOW TWO OPTIONS TO READ IN YOUR DATA FROM EXCEL
# one version is for password protected files

## Excel file ---------------------------
#
## To read in a specific sheet use "which"
# linelist_raw <- rio::import("linelist.xlsx", which = "Sheet1")

## Excel file (password-protected) ------
#
## Use the excel.link package 
# library(excel.link)
# linelist_raw <- xl.read.file("linelist.xlsx",
#                              xl.sheet = "Sheet1",
#                              password = askpass::askpass(prompt = "please enter file password"))

## DELETE THIS LINE --- YOU READ IN YOUR OWN DATA ABOVE!
linelist_raw <- gen_data("Cholera") # generates a fake dataset for use as an example in this template

## MSF Cholera Dictionary ---------------
#
## get MSF data dictionary for cholera 
linelist_dict <- msf_dict("Cholera")

## you can look at the standard dictionary by uncommenting the line below
# View(linelist_dict) 

## you can view variable names in the standard data dicationry uncommenting the line below
# linelist_dict$data_element_shortname


# Clean column names ---------------------------------------------

## a good first step is to assign standard column names so that subsequent code
## uses stable column names. In case the input data changes, you just need to
## fix the column mapping.

## make a copy of your orginal dataset and name it linelist_cleaned
linelist_cleaned <- linelist_raw

## UNCOMMENT AND RUN TWO LINES OF CODE BELOW!
##
## define clean variable names using clean_labels from the epitrix package. This
## function defines rules for variable naming; for example, it changes spaces
## and dots to "_" and sets all characters to lowercase.

# cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))
# colnames(linelist_cleaned) <- cleaned_colnames # overwrite variable names with defined clean names

## OPTIONAL: below is just an example in case you want to specifically change a
## few names you can also change specific var names using the *rename*
## function. In this example, we have the columns "gender" and "age" that we
## want to rename as "sex" and "age_years".
## The formula for this is rename(data, NEW_NAME = OLD_NAME)

# linelist_cleaned <- rename(linelist_cleaned, 
#                            gender    = sex, 
#                            age_years = age)


## OPTIONAL: if you only want to keep certain variables - 
## you can select these by name or column number view the names of your vars
## and their column number using: names(linelist_cleaned) this example keeps
## the first three columns as well as age_years and sex variables

# linelist_cleaned <- select(linelist_cleaned, c(1:3, "age_years", "sex")

## Standardising values --------------------------------------------
## 
## Data entered in through software will often code values in a compact format
## to save space. For example, Yes/No values will often be coded as 1 or 0 and
## sex coded as M or F. This line uses the MSF dictionary to recode these values
## back to a human-readable format.
linelist_cleaned <- switch_vals(df = linelist_cleaned, disease = "Cholera")
```


```{r read_DHIS_csv_data}

# If your linelist is a csv export of data from DHIS2 use this code chunk
# This assumes your data fits the standardised MSF data dictionary for this disease

## Read data ------------------------------------------------------
# CSV file
# linelist_raw <- rio::import("linelist.csv")

## get MSF data dictionary for cholera 
# linelist_dict <- msf_dict("Cholera")

## Fixing variable names ----------------------
## make a copy of your original dataset and name it linelist_cleaned
# linelist_cleaned <- linelist_raw

## define clean variable names using clean_labels from the epitrix package
# cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))

## overwrite variable names with excel version names from data dictionary
## return which rows in the data dictionary match your column names

# match_cols <- match(cleaned_colnames, linelist_dict$data_element_name, nomatch = 0)
# cleaned_colnames[match_cols > 0] <- linelist_dict$data_element_shortname[match_cols]

## overwrite variable names with defined clean names
# colnames(linelist_cleaned) <- cleaned_colnames


## Standardising values --------------------------------------------
## 
## Data entered in through software will often code values in a compact format
## to save space. For example, Yes/No values will often be coded as 1 or 0 and
## sex coded as M or F. This line uses the MSF dictionary to recode these values
## back to a human-readable format.
## linelist_cleaned <- switch_vals(df = linelist_cleaned, disease = "Cholera")
```



```{r read_nonDHIS_data}

## IF YOUR LINELIST NOT AN EXPORT OF DATA FROM DHIS2 USE THIS CODE CHUNK ------
##
## This assumes your data does not fit the standardised MSF data dictionary for
## this disease.
##
## Checklist to clean and update this script to match your data ---------------
## 
## - [ ] Recode your variable names to match this analysis 
## - [ ] Recode variable contents
## - [ ] update the code later in the script to fit your names/contents
##
## You will still need to read in the standardised data dictionary
##   This is to understand which variables are being used later in the script
##   So that you can adapt those later code chunks to fit your dataset
##
## - [ ] run this to look at the data dictionary: 
# linelist_dict <- msf_dict("Cholera")
# View(linelist_dict) 


## Read data ------------------------------------
# Excel file
# to read in a specific sheet use "which"
# linelist_raw <- rio::import("linelist.xlsx", which = "Sheet1")
# 
# For password protected Excel file 
# use the excel.link package 
# library(excel.link)
# linelist_raw <- xl.read.file("linelist.xlsx",
#                              xl.sheet = "Sheet1",
#                              password = askpass::askpass("please enter file password"))
# CSV file
# linelist_raw <- rio::import("linelist.csv")
# 
# Stata data file
# linelist_raw <- rio::import("linelist.dat")

## Fixing variable names ----------------------

# define clean variable names using clean_labels from the epitrix package
# this function is preset rules for variable naming 
# for example it changes spaces and dots to "_" and characters to lowercase
# cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))

# overwrite variable names with defined clean names
# colnames(linelist_cleaned) <- cleaned_colnames

## OPTIONAL: below is just an example in case you want to specifically change a
## few names you can also change specific var names using the *rename*
## function. In this example, we have the columns "gender" and "age" that we
## want to rename as "sex" and "age_years".
## The formula for this is rename(data, NEW_NAME = OLD_NAME)

# linelist_cleaned <- rename(linelist_cleaned, 
#                            gender    = sex, 
#                            age_years = age)

# You can use the function msf_dict_rename_helper() to create a template based
# on the cholera dictionary
msf_dict_rename_helper("Cholera")


## OPTIONAL: if you only want to keep certain variables - 
## you can select these by name or column number view the names of your vars
## and their column number using: names(linelist_cleaned) this example keeps
## the first three columns as well as age_years and sex variables

# linelist_cleaned <- select(linelist_cleaned, c(1:3, "age_years", "sex")
```








```{r read_population_data}

## Read data ------------------------------------

# Excel file
# to read in a specific sheet use "which"
# population_data <- rio::import("population.xlsx", which = "Sheet1")

# repeat same cleaning steps as above
# make sure your place variable name matches!

## Counts from population proportions ------------------------------------ 
# if you only know the total population and the proportions in each age group, use this function 
# population_data_age <- gen_population(total_pop = 1000, 
#                                       groups = c("0-4","5-14","15-24","25-34","35-44","45+"),
#                                       proportions = c(0.182, 0.278, 0.26, 0.11, 0.07, 0.10)
#                                       )

## Fake data ------------------------------------ 
# THE BELOW CAN BE DELETED IF YOU HAVE YOUR OWN (REAL) POPULATION DATA! 
# its just to be able to demonstrate script in this template

# generate some artificial population data by region 
population_data_region <- distinct(linelist_cleaned, patient_origin_free_text)
population_data_region$population <- as.integer(runif(nrow(population_data_region), 
                                          min = 500, max = 2000))

# generate some artificial population data by age groups (years)
population_data_age <- tibble(age_group = c("0-4","5-14","15-29","30-44", "45+"))
population_data_age$population <- as.integer(runif(nrow(population_data_age), 
                                          min = 500, max = 2000))

# generate some artifical population data by age group (months) 
population_data_age_months <- tibble(age_group_mon = c("0-5", "6-8", "9-10","11-22", "23+"))
population_data_age_months$population <- as.integer(runif(nrow(population_data_age_months), 
                                          min = 500, max = 2000))
```



```{r browse_data, eval = FALSE}
# Browsing data ---------------------------------
# here are a few ways to do data explorations 

# view the first ten rows of data
head(linelist_cleaned, n = 10)

# view your whole dataset interactivley (in an excel style format)
## Remember that `View` needs to be written with a capital *V*
View(linelist_cleaned)

# overview of variable types and contents
str(linelist_cleaned)

# gives mean, median and max values of variables
summary(linelist_cleaned)

# view unique values contained in variables 
unique(linelist_cleaned$sex)

# another alternative is with the "summarytools package"
# use the dfSummary function in combination with view
# note that view is not capitalised with this package
# install.packages("summarytools")
# summarytools::view(summarytools::dfSummary(linelist_cleaned))
```





```{r standardise_clean_data}
# Next, document anything to clean data. Use dplyr for that.

# Date variables ---------------------------------
# IF YOU ARE USING THE DATA DICTIONARY USE THIS OTHERWISE UNCOMMENT LINES BELOW
# make sure all date variables are formatted as dates 
DATEVARS <- filter(linelist_dict, data_element_valuetype == "DATE") %>% 
  select(data_element_shortname) # select date vars
# change to dates 
linelist_cleaned <- linelist_cleaned %>%
  mutate_at(DATEVARS$data_element_shortname, as.Date)

# if you dont have a data dictionary you could do it this way too
# linelist_cleaned <- linelist_cleaned %>%
#   mutate_at(vars(matches("date|Date")), as.Date)

# set unrealistic dates to NA, based on having browsed dates in the previous chunk
# linelist_cleaned <- mutate(linelist_cleaned,
#                            date_of_onset < as.Date("2017-11-01") ~ NA, 
#                            date_of_onset == as.Date("2081-01-01") ~ as.Date("2018-01-01"))
  
# create an epiweek variable 
linelist_cleaned$epiweek <- ISOweek(linelist_cleaned$date_of_onset)


# Numeric variables --------------------------------- 
# create number of days under observation
linelist_cleaned <- mutate(linelist_cleaned, 
                           obs_days = as.numeric(date_of_exit - date_of_consultation_admission))


# Age group variables ---------------------------------

# OPTIONAL: add under 2 years to the age_years variable
# data dictionary defines that under 2s dont have year filled in (but months/days instead)
linelist_cleaned <- linelist_cleaned %>% 
  mutate(age_years = case_when(
    is.na(age_years) & is.na(age_months) ~ as.integer(age_days / 365.25),
    is.na(age_years)                     ~ as.integer(age_months / 12),
    TRUE                                 ~ age_years
  ))

# change those who are above or below a certain age to NA
# linelist_cleaned <- mutate(linelist_cleaned, 
#                            age_years = case_when(
#                              age_years <0 ~ NA, 
#                              age_years >120 ~ NA
#                            ))

# create an age group variable by specifying categorical breaks (of years)
linelist_cleaned$age_group <- age_categories(linelist_cleaned$age_years, 
                                             breakers = c(0, 5, 15, 30, 45))

# alternatively, create an age group variable specify a sequence
# linelist_cleaned$age_group <- age_categories(linelist_cleaned$age,
#                                              lower = 0, 
#                                              upper = 100, 
#                                              by = 10)

# If you already have an age group variable defined, you should manually
# arrange the categories
# linelist_cleaned$age_group <- factor(linelist_cleaned$age_group,
#                                      c("0-4y", "5-14y", "15-29y", "30-44y", "45+y"))


# create age group variable for under 5 years based on months
linelist_cleaned$age_group_mon <- age_categories(linelist_cleaned$age_months, 
                                                 breakers = c(0, 6, 9, 11, 23))

# Factor (categorical) variables ---------------------------------

# recode a factor character variable
# fix any misspellings in the data
# linelist_cleaned <- linelist_cleaned %>%
#   mutate(patient_origin_free_text = recode(patient_origin_free_text,
#     # List all incorrect mis-spellings here ("old" = "new")
#     "Valliages DD" = "Village D"
#   ))


# Change the level labels of a categorical variable
linelist_cleaned$sex <- recode_factor(linelist_cleaned$sex, 
                                      "Male" = "Male", 
                                      "Female" = "Female", 
                                      "Unknown/unspecified" = NA_character_)


# change the order of levels in a single categorical variable 
linelist_cleaned <- linelist_cleaned %>% 
  mutate(time_to_death = factor(time_to_death, 
                                levels = c("0-4 hours", 
                                           ">4-24 hours", 
                                           ">24-48 hours", 
                                           ">48 hours")
  ))


# change the order of levels of multiple categorical variables
linelist_cleaned <- linelist_cleaned %>%
  mutate_at(vars(starts_with("dehydration")), 
            list(~factor(., levels = c("None", "Some", "Severe", "Unknown")))
           )

# Create a factor variable based on rules from other simple character variables
# create a case definition variable 
# the tilda (~) is used to assign the new values (Conf, prob, susp, unknown)
# starting from the specific to the general
# TRUE assigns all remaining rows 
# linelist_cleaned <- linelist_cleaned %>%
#   mutate(case_def = case_when(
#     test_result == "Positive"                     ~ "Confirmed",
#     test_result == "Negative" & symptoms == "Yes" ~ "Probable",
#     test_result == "Negative"                     ~ "Suspected",
#     TRUE                                          ~ "Unknown"
#   ))

# create a case definition variable based on searching other variables
# grepl is used to search for words within a character variable
# the tilda (~) is used to assign the new values (Conf, prob, susp, unknown)
# starting from the specific to the general
# TRUE assigns all remaining rows 
linelist_cleaned <- linelist_cleaned %>%
  mutate(case_def = case_when(
    grepl("Positive", cholera_pcr_result)     ~ "Confirmed",  
    grepl("Positive", cholera_culture_result) ~ "Confirmed",
    grepl("Positive", cholera_rdt_result)     ~ "Probable",
    TRUE                                      ~ "Suspected"
  ))
```



```{r define_current_week}

# In order to automate your report you need define week of interest (reporting_week)
# This will generally be one week in the past from when you write your report

# to demonstrate in this template we will take the maximum epiweek
# however you can define epiweek by hand as below
reporting_week <- max(linelist_cleaned$epiweek)

# define current week 
# reporting_week <- "2018-W10"

# outbreak start 
# return the first day in the week of first case 
obs_start <- ISOweek2date(paste0(min(linelist_cleaned$epiweek), "-1"))

# return last day of reporting week 
obs_end <- ISOweek2date(paste0(max(linelist_cleaned$epiweek), "-7"))

# drop cases after current week
# you will probably have cases in your dataset if case finding continues
# as these are after the week of reporting, drop them
linelist_cleaned <- linelist_cleaned %>% 
  filter(epiweek <= reporting_week)
```





### Person

* [Who is affected: how many in total; male or female; young, adult or old? What are the links between affected people – work place, school, social gathering?  Is there a high rate of illness in contacts?  Is there a high rate of illness in health workers? You may want to include:  a bar chart showing case numbers or incidence by age group and sex; attack rates (AR); and numbers of deaths (in suspected and confirmed cases), mortality rates and/or case fatality ratio (CFR)]  


From the start of the outbreak up until `r reporting_week` there were a 
total of `r nrow(linelist_cleaned)` cases. There were
`r linelist_cleaned %>% filter(sex == "Female") %>% count() %>% pull(n)` females affected and
`r linelist_cleaned %>% filter(sex == "Male") %>% count() %>% pull(n)` males. 

The most affected age group was `r descriptive(linelist_cleaned, "age_group") %>% slice(which.max(n)) %>% pull(age_group)` years. 


#### Demographics 



Cases by age group and definition 

```{r describe_by_age_group_and_def}
# get counts and props of age groups by case definition 
# include column and row totals 
descriptive(linelist_cleaned, "age_group", "case_def", coltotals = TRUE, rowtotals = TRUE) %>% 
  rename("Age group (years)" = age_group, 
         "Confirmed cases (n)" = Confirmed_n, 
         "%" = Confirmed_prop, 
         "Probable cases (n)" = Probable_n, 
         "%" = Probable_prop,
         "Suspected cases (n)" = Suspected_n, 
         "%" = Suspected_prop) %>% 
  kable(digits = 2)
```




Cases by age group and sex 

```{r describe_by_age_group_and_sex}
descriptive(linelist_cleaned, "age_group", "sex", coltotals = TRUE, rowtotals = TRUE) %>% 
  rename("Age group (years)" = age_group, 
         "Female cases (n)" = Female_n, 
         "%" = Female_prop, 
         "Male cases (n)" = Male_n, 
         "%" = Male_prop,
         "Missing (n)" = NA_n, 
         "%" = NA_prop) %>% 
  kable(digits = 2)
```



Age pyramid by case definition 

There were `r sum(is.na(linelist_cleaned$sex))` cases missing information on sex, 
`r sum(is.na(linelist_cleaned$case_def))` missing case definitions and 
`r sum(is.na(linelist_cleaned$age_group))` missing age group.

```{r age_pyramid, warning=FALSE}
# plot age pyramid 
 
plot_age_pyramid(linelist_cleaned, 
                 age_group = "age_group", 
                 split_by = "sex", 
                 stack_by = "case_def") + 
  labs(y = "Cases (n)", x = "Age group (years)") + # change axis labels (nb. x/y flip)
  theme(legend.position = "bottom",     # move legend to bottom
        legend.title = element_blank(), # remove title
        text = element_text(size = 18)  # change text size
       )
```



```{r age_pyramid_U2, warning=FALSE}
# plot age pyramid under 2s
# filter(linelist_cleaned, age_years <= 2) %>%
#   plot_age_pyramid(age_group = "age_group_mon", 
#                    split_by = "sex",
#                    stack_by = "case_def") +
#   labs(x = "Cases (n)", y = "Age group (months)") + # change axis labels (nb. x/y flip)
#   theme(legend.position = "bottom",     # move legend to bottom
#         legend.title = element_blank(), # remove title
#         text = element_text(size = 18)  # change text size
#        )
```

```{r treatment_plans, warning = FALSE}
# summarize the number of patients admitted to treatment plans for printing in
# the report. 
trtpln <- descriptive(linelist_cleaned, counter = "fluids_treatment_plan") %>%
  # Create a variable that displays the number of people followed by xx.x%
  # change the %.1f to %.2f if you want more digits in your percentages
  mutate(to_print = sprintf("%d (%.1f%%)", n, prop))

# number of people in the plans A, B, and C
trtplnA <- filter(trtpln, grepl("A$", fluids_treatment_plan)) %>% pull(to_print)
trtplnB <- filter(trtpln, grepl("B$", fluids_treatment_plan)) %>% pull(to_print)
trtplnC <- filter(trtpln, grepl("C$", fluids_treatment_plan)) %>% pull(to_print)
```

From the start of the outbreak, `r trtplnA` patients were admitted to treatment
plan A, `r trtplnB` were admitted to treatment plan B, with `r trtplnC` being
admitted to treatment plan C.

Cases by treatment plan and case definition

```{r describe_by_treatment_plan_case_def}
descriptive(linelist_cleaned, 
            counter = "fluids_treatment_plan", 
            grouper = "case_def", 
            coltotals = TRUE, 
            rowtotals = TRUE) %>% 
  rename("Fluid treatment plan" = fluids_treatment_plan, 
         "Confirmed cases (n)" = Confirmed_n, 
         "%" = Confirmed_prop, 
         "Probable cases (n)" = Probable_n, 
         "%" = Probable_prop,
         "Suspected cases (n)" = Suspected_n, 
         "%" = Suspected_prop) %>% 
  kable(digits = 2)
```


The median number of days admitted was `r median(linelist_cleaned$obs_days)`, 
with a range between `r min(linelist_cleaned$obs_days)` and `r max(linelist_cleaned$obs_days)` days. 
A total of `r filter(linelist_cleaned, readmission == "Yes") %>% nrow()` patients were readmitted to the CTC. 


Cases by dehyrdation severity at admission

```{r describe_by_illness_severity_admission}
descriptive(linelist_cleaned, 
            counter = "dehydration_level_at_admission", 
            coltotals = TRUE) %>% 
  rename("Dehydration severity" = dehydration_level_at_admission, 
         "Cases (n)" = n, 
         "%" = prop) %>% 
  kable(digits = 2)
```

Cases by dehydration severity during stay 

```{r describe_by_illness_severity_stay}
descriptive(linelist_cleaned, 
            counter = "dehydration_severity_during_stay", 
            coltotals = TRUE) %>% 
  rename("Dehydration severity" = dehydration_severity_during_stay, 
         "Cases (n)" = n, 
         "%" = prop) %>% 
  kable(digits = 2)
```


#### Case fatality ratio 

To date, there have been `r sum(grepl("Dead", linelist_cleaned$exit_status))` deaths, of which 
`r linelist_cleaned %>% filter(exit_status == "Dead on arrival") %>% nrow()` 
were dead on arrival. 

Among those who died, the time to death is shown below. 

```{r describe_time_to_death}
DIED <- grepl("Dead", linelist_cleaned$exit_status)

filter(linelist_cleaned, DIED) %>% 
  descriptive(counter = "time_to_death", coltotals = TRUE) %>% 
  rename("Time (hours)" = time_to_death, 
         "Deaths (n)" = n, 
         "%" = prop) %>% 
  kable(digits = 2)
```



The case fatality ratio among those with known outcomes is below

```{r overall_cfr}
# use arguments from above to produce overal CFR
linelist_cleaned %>% 
  filter(!is.na(exit_status)) %>%  # remove rows with missing outcome
  summarise(deaths = sum(DIED),    # tally deaths
            population = n()) %>%  # count population
  # calculate case fatality rate
  do(case_fatality_rate(.$deaths, .$population, mergeCI = TRUE)) %>% 
  rename("Deaths" = deaths,
         "Population" = population,
         "CFR (%)" = cfr,
         "95% CI" = ci) %>%
  knitr::kable(digits = 2)         # print nicely with 2 digits
```


The case fatality ratio by sex among those with known outcomes is below. 

```{r cfr_by_sex}
# group by known outcome and sex
linelist_cleaned %>% 
  filter(!is.na(exit_status)) %>%               # remove rows with missing outcome
  group_by(sex) %>%                              # group by sex
  summarise(deaths = sum(grepl("Dead", exit_status)),        # tally deaths
            population = n()) %>%                # tally population
  # calculate case fatality rate
  do(bind_cols(sex = .$sex, 
               case_fatality_rate(.$deaths, .$population, mergeCI = TRUE))) %>% 
  rename("Sex" = sex, 
         "Deaths" = deaths, 
         "Population" = population, 
         "CFR (%)" = cfr, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2)
```



CFR by age group among those with known outcomes

```{r cfr_by_age_group}
# group by known outcome and agegroup 
linelist_cleaned %>% 
  filter(!is.na(exit_status)) %>%               # remove rows with missing outcome
  group_by(age_group) %>%                        # group by age_group
  summarise(deaths = sum(grepl("Dead", exit_status)),    # tally deaths
            population = n()) %>%                # tally population
  # calculate case fatality rate
  do(bind_cols(age_group = .$age_group, 
               case_fatality_rate(.$deaths, .$population, mergeCI = TRUE))) %>% 
   tidyr::complete(age_group) %>%               # Ensure all levels are represented
  rename("Age group (years)" = age_group, 
         "Deaths" = deaths, 
         "Population" = population, 
         "CFR (%)" = cfr, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2)
```

CFR by case definition among those with known outcomes

```{r cfr_by_case_def}
# group by known outcome and case definition 
linelist_cleaned %>% 
  filter(!is.na(exit_status)) %>%               # remove rows with missing outcome
  group_by(case_def) %>%                        # group by case_def
  summarise(deaths = sum(grepl("Dead", exit_status)),    # tally deaths
            population = n()) %>%               # tally population
  # calculate case fatality rate
  do(bind_cols(case_def = .$case_def, 
               case_fatality_rate(.$deaths, .$population, mergeCI = TRUE))) %>% 
  tidyr::complete(case_def) %>%                 # Ensure all levels are represented
  rename("Case definition" = case_def, 
         "Deaths" = deaths, 
         "Population" = population, 
         "CFR (%)" = cfr, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2)
```


#### Attack rate

The attack rate per 10,000 population is below - based on available population data for the whole country. 

```{r collect_variables}
# define population 
population <- sum(population_data_age$population)
```

```{r attack_rate}
# calculate the ar
# store as AR to be able to use output for automating text below
ar <- attack_rate(nrow(linelist_cleaned), population, multiplier = 10000)

rename(ar, 
       "Cases (n)" = cases,
       "Population" = population, 
       "AR (per 10,000)" = ar,
       "lower 95%CI" = lower, 
       "Upper 95%CI" = upper
       ) %>% 
  knitr::kable(digits = 2)
```

Here, we can see that the Attack Rate for a population of `r format(population, big.mark = ",")` was `r fmt_ci_df(ar)`.

To give attack rate by age group, with appropriate population denominators, use the following code. 

```{r attack_rate_by_agegroup, warning = FALSE}
cases <- count(linelist_cleaned, age_group) %>%   # cases for each week
  left_join(population_data_age, by = "age_group")    # merge population data 

# attack rate for each week
attack_rate(cases$n, cases$population, multiplier = 100000, mergeCI = TRUE) %>% 
  # add the epiweek column to table
  bind_cols(select(cases, age_group), .) %>% 
  rename("Age group (y)" = age_group, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "95%CI" = ci) %>% 
  kable(digits = 2, format.args = list(big.mark = ",")) # set thousands separator
```


#### Mortality

This demonstrates three ways of calculating mortality rate based on 
catchment population (twice) and based on hospital population. 

```{r collect_variables_rates}
# count number of deaths 
deaths <- filter(linelist_cleaned, 
                 exit_status == "Dead in facility" | exit_status == "Dead on arrival") %>% 
  nrow()

# outbreak duration in days 
obs_time <- as.numeric(obs_end - obs_start)

# patient observation time 
pat_obs_time <- linelist_cleaned %>% 
  filter(!is.na(exit_status)) %>% 
  summarise(days = sum(obs_days)) %>%
  pull(days)
```

To produce a mortality rate per 10,000 people use the following code chunk. 
This assumes that you are capturing every death in your population. 

```{r mortality_rate}
mortality_rate(deaths, population, multiplier = 10000) %>%
  rename("Deaths" = deaths, 
         "Population" = population, 
         "Mortality (per 10,000)" = `mortality per 10 000`, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  kable(digits = 2)
```

To produce a crude mortality rate per 10,000 people per day, use the folowing 
code chunk. 
This assumes that you are capturing every death in your population and that 
your population remains stable over the time period of interest. 
In this situation the time period of interest is from the beginning of the 
epiweek your first case occured in, until the last day of the epiweek you are 
currently reporting on. (see this [presentation](https://www.odi.org/sites/odi.org.uk/files/odi-assets/events-presentations/776.pdf) for more detail)


```{r mortality_rate_CMR}
mortality_rate(deaths, population*obs_time, multiplier = 10000) %>%
  rename("Deaths" = deaths, 
         "person-days" = population, 
         "Mortality (per 10,000/day)" = `mortality per 10 000`, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  kable(digits = 2)
```

Alternatively, if you are unsure whether your hospital deaths are representative
of the wider population, use the following code chunk. 
This uses the person days of cases in your linelist with a known outcome. 
However, this will give you an unreasonably high mortality rate, as 
those in hospital will only be the most severely affected. 

```{r mortality_rate_patients}
mortality_rate(deaths, pat_obs_time, multiplier = 10000) %>%
  rename("Deaths" = deaths, 
         "Population" = population, 
         "Mortality (per 10,000/day)" = `mortality per 10 000`, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  kable(digits = 2)
```


### Time

* [When did the cases fall ill? Are numbers increasing or stable? You may want to include an Epi curve (bar chart showing number of new (suspected and confirmed) cases each day/week) ]

There were `r sum(is.na(linelist_cleaned$date_of_onset))` cases missing dates of onset. 

```{r create_incidence, message = FALSE}
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, interval = 7)
epicurve_theme <- theme(
  axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
  legend.title = element_blank()
  )
```

The peak of the outbreak was in `r ISOweek(find_peak(inc_week_7))`

```{r epicurve, message = FALSE}
# plot your epicurve
basic_curve <- plot(inc_week_7, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7)) + 
  scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "Cases (n)", 
       subtitle = paste0("Source: MSF data from ", reporting_week)) + 
  # change visuals of dates and remove legend title
  epicurve_theme

# show your plot (stored for later use) 
basic_curve
```


You may also want to stratify by gender. 


```{r incidence_by_gender, message = FALSE}
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, 
                        interval = 7, 
                        groups = linelist_cleaned$sex)
plot(inc_week_7, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7)) + 
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "Cases (n)", 
       subtitle = paste0("Source: MSF data from ", reporting_week)) + 
  # change visuals of dates, remove legend title and move legend to bottom
  epicurve_theme
```


You could similarly stratify by case definition (or any other categorical variable!)


```{r incidence_by_case_def, message = FALSE}
inc_week_7 <- incidence(linelist_cleaned$date_of_onset, 
                        interval = 7, 
                        groups = linelist_cleaned$case_def)
plot(inc_week_7, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7)) + 
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "Cases (n)", 
       subtitle = paste0("Source: MSF data from ", reporting_week)) + 
  # change visuals of dates, remove legend title and move legend to bottom
  epicurve_theme
```


Alternatively, you could stratify by sex among a subset of only confirmed cases. 


```{r incidence_by_sex_confirmed, message = FALSE}
inc_week_7 <- incidence(linelist_cleaned$date_of_onset[linelist_cleaned$case_def == "Confirmed"], 
                        interval = 7, 
                        groups = linelist_cleaned$sex[linelist_cleaned$case_def == "Confirmed"])
plot(inc_week_7, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7)) + 
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "Cases (n)", 
       subtitle = paste0("Source: MSF data from ", reporting_week)) + 
  # change visuals of dates, remove legend title and move legend to bottom
  epicurve_theme
```


The below gives the attack rate per week. 

```{r attack_rate_per_week}
# counts and cummulative counts by week
cases <- count(linelist_cleaned, epiweek) %>% 
  mutate(cummulative = cumsum(n))

# attack rate for each week
ar <- attack_rate(cases$n, population, multiplier = 100000) %>% 
  # add the epiweek column to table
  bind_cols(select(cases, epiweek), .)

ar %>%
  merge_ci_df(e = 4) %>% # merge the upper and lower CI into one column
  rename("Epiweek" = epiweek, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2, align = "r")
```
 

The below gives the cummulative attack rate per week. 

```{r cummulative_attack_rate_per_week}
# cummulative attack rate by week
attack_rate(cases$cummulative, population, multiplier = 100000) %>% 
  # add the epiweek column to table
  bind_cols(select(cases, epiweek), .) %>% 
  merge_ci_df(e = 4) %>% # merge the upper and lower CI into one column
  rename("Epiweek" = epiweek, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2, align = "r")
```

The below gives case fatility rate per week as a proportion

```{r cfr_per_week}
# group by known outcome and case definition 
cfr <- linelist_cleaned %>% 
  filter(!is.na(exit_status)) %>%               # remove rows with missing outcome
  group_by(epiweek) %>%                        # group by case_def
  summarise(deaths = sum(grepl("Dead", exit_status)),  # tally deaths
            population = n()) %>%               # tally population
  # calculate case fatality rate
  do(bind_cols(epiweek = .$epiweek, 
               case_fatality_rate(.$deaths, .$population))) %>% 
  tidyr::complete(epiweek)                 # Ensure all levels are represented

cfr %>%
  merge_ci_df(e = 4) %>%
  rename("Epiweek" = epiweek, 
         "Deaths" = deaths, 
         "Population" = population, 
         "CFR (%)" = cfr, 
         "95%CI" = ci) %>% 
  knitr::kable(digits = 2, align = "r")
```


You could plot the AR and CFR together as line graphs by epiweek. 

```{r ar_line_graph}
ar_plot <- ggplot(ar, aes(x = epiweek, group = 1)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), color = "blue", fill = "blue", linetype = 2, alpha = 0.2, show.legend = FALSE) +
  geom_line(aes(y = ar), color = "blue", show.legend = FALSE) +
  scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
  scale_x_discrete(limits = c(ar$epiweek, ""), expand = c(0, 1)) + # add extra break to match epicurve
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "AR [95% CI]", subtitle = "Attack Rate (per 100,000)") + 
  # change visuals of dates and remove legend title
  epicurve_theme
```


```{r cfr_line_graph}
cfr_plot <- ggplot(cfr, aes(x = epiweek, group = 1)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), color = "red", fill = "red", linetype = 2, alpha = 0.2, show.legend = FALSE) +
  geom_line(aes(y = cfr), color = "red", show.legend = FALSE) +
  scale_y_continuous(expand = c(0, 0), 
                     limits = c(0, 100), breaks = c(0, 25, 50, 75, 100)) +  # set origin for axes
  scale_x_discrete(limits = c(ar$epiweek, ""), expand = c(0, 1)) + # add extra break to match epicurve
  # add labels to axes and below chart
  labs(x = "Calendar week", y = "CFR [95% CI]", subtitle = "Case Fatality Rate [95% CI]") + 
  # change visuals of dates and remove legend title
  epicurve_theme 
```


You could then also add the AR and CFR by week on to an epicurve. 

```{r epicurve_ar_cfr, message = FALSE, fig.height = 10}
nofx <- theme(axis.text.x = element_blank(),
              axis.title.x = element_blank())
cowplot::plot_grid(
  basic_curve + nofx,
  ar_plot + nofx,
  cfr_plot,
  align = "v", # align plots vertically
  axis = "lr", # only by their left and right margins
  ncol = 1     # allow only one column
)
```


### Place

*  [Across what area: one or several villages, all from same school, etc. You may want to include a map of the distribution of cases; attack rates by location]

#### Descriptive
To get a basic descriptive table of cases by region and outcome, see below. 

```{r describe_by_region_outcome}
# get counts and props of region by outcome 
# include column and row totals 
descriptive(linelist_cleaned, "patient_origin_free_text", "exit_status", 
            coltotals = TRUE, rowtotals = TRUE) %>% 
  rename("Region" = "patient_origin_free_text", 
         "Died facility (n)" = "Dead in facility_n", 
         "%" = "Dead in facility_prop", 
         "Died arrival (n)" = "Dead on arrival_n", 
         "%" = "Dead on arrival_prop",
         "Discharged (n)" = "Discharged home_n", 
         "%" = "Discharged home_prop", 
         "Left against advice (n)" = "Left against medical advice_n", 
         "%" = "Left against medical advice_prop", 
         "Transferred MSF facility (n)" = "Transferred (to an MSF facility)_n", 
         "%" = "Transferred (to an MSF facility)_prop", 
         "Transferred external facility (n)" = "Transferred (to External Facility)_n", 
         "%" = "Transferred (to External Facility)_prop", 
         "Total" = "Total"
         ) %>% 
  kable(digits = 2)
```




If you do not have spatial data available, it may also be worth calculating attack rates by region. 

```{r attack_rate_by_region}
cases <- count(linelist_cleaned, patient_origin_free_text) %>%   # cases for each region
  left_join(population_data_region, by = "patient_origin_free_text")    # merge population data 
# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>% 
  # add the region column to table
  bind_cols(select(cases, patient_origin_free_text), .) %>% 
  
  rename("Region" = patient_origin_free_text, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) 
kable(ar, digits = 2, align = "r", format.args = list(big.mark = ",")) # set thousands separator
```

You could then also plot this on a bar chart with confidence intervals. 

```{r bar_attack_rate_by_region}
# plot with the region on the x axis sorted by increasing ar
# ar value on the y axis 
ggplot(ar, aes(x = reorder(Region, `AR (per 100,000)`),
               y = `AR (per 100,000)`)) + 
  geom_bar(stat = "identity", col = "black", fill = "red") + # plot as bars (identity = as is)
  geom_errorbar(aes(ymin = `Lower 95%CI`, ymax = `Upper 95%CI`), width = 0.2) + # add CIs
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  # add labels to axes and below chart
  labs(x = "Region", y = "AR (per 100,000)", 
       captions = paste0("Source: MSF data from ", reporting_week))

```


You could also calculate mortality rate by region (cross reference with the mortality code chunk in person section for assumptions). 

```{r mortality_rate_region}

deaths <- group_by(linelist_cleaned, patient_origin_free_text) %>%
   filter(exit_status == "Dead in facility" | 
            exit_status == "Dead on arrival") %>% 
  summarise(deaths = n()) %>%                 # count deaths by region
  left_join(population_data_region, by = "patient_origin_free_text")    # merge population data 

mortality_rate(deaths$deaths, deaths$population, multiplier = 10000) %>%
  # add the region column to table
  bind_cols(select(deaths, patient_origin_free_text), .) %>% 
  rename("Region" = patient_origin_free_text, 
         "Deaths" = deaths, 
         "Population" = population, 
         "Mortality (per 10,000)" = `mortality per 10 000`, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper) %>% 
  kable(digits = 2)
```




#### Maps 



```{r download_spatial_maps, message=FALSE}

# DELETE THIS LINE IF YOU HAVE YOUR OWN SHAPEFILE
# generate fake shapefile
map <- gen_polygon(regions = unique(linelist_cleaned$patient_origin_free_text))

# reading in a shapefile 
# shapefiles consist of multiple files
# so you dont need to specify the file type (reas_sf recognises it for you)
# map <- read_sf(here("mapfolder", "china"))


## check the CRS
# st_crs(map)
## set the CRS if not present using EPSG value
# map <- st_set_crs(map, value = 4326) # Sets to WGS84
## Transform to a different CRS such as UTM, search online for relvant EPSG value
# map_otherprojection <- st_transform(map, value = 32646) 
```

The following will plot a map based on the attack rate table. 


```{r choropleth_maps, message = FALSE, warning = FALSE}

mapsub <- left_join(map, ar, by = c("name" = "Region"))

# choropleth 
ggplot() +
  geom_sf(data = mapsub, aes(fill = `AR (per 100,000)`), col = "grey50") + # shapefile as polygon
  coord_sf(datum = NA) + # needed to avoid gridlines being drawn
  annotation_scale() + # add a scalebar
  scale_fill_viridis_c(option = "C") + # color the scale to be perceptually uniform
  theme_void() # remove coordinates and axes
```


You could then also throw your plot of region and the choropleth in a map to 
produce this for each week in a for-loop. 

```{r map_for_loop_epiweek, message = FALSE, warning = FALSE, fig.width = 12}
# change region variable to a factor so that zero counts can be included
linelist_cleaned$patient_origin_free_text <- as.factor(linelist_cleaned$patient_origin_free_text)

# case counts
cases <- linelist_cleaned %>% 
  group_by(epiweek) %>%
  count(patient_origin_free_text) %>%   # cases for each week by region
  tidyr::complete(patient_origin_free_text, fill = list(n = 0)) %>% # include zero counts
  left_join(population_data_region, by = "patient_origin_free_text")    # merge population data 

# attack rate for region
ar <- attack_rate(cases$n, cases$population, multiplier = 100000) %>% 
  # add the region column to table
  bind_cols(select(cases, epiweek, patient_origin_free_text), .) %>% 
  rename("Region" = patient_origin_free_text, 
         "Cases (n)" = cases, 
         "Population" = population, 
         "AR (per 100,000)" = ar, 
         "Lower 95%CI" = lower,
         "Upper 95%CI" = upper)
max_cases <- max(cases$n, na.rm = TRUE) # define the maximum number of cases for the color palette 
max_ar    <- max(ar$`Upper 95%CI`, na.rm = TRUE)
# go through each epiweek, fiter and plot the data
for (i in unique(cases$epiweek)) {
  this_ar <- filter(ar, epiweek == i)
  
  # map 
  mapsub <- left_join(map, this_ar, by = c("name" = "Region"))
  
  # choropleth 
  map_plot <- ggplot() +
    geom_sf(data = mapsub, aes(fill = `Cases (n)`), col = "grey50") + # shapefile as polygon
    coord_sf(datum = NA) + # needed to avoid gridlines being drawn
    annotation_scale() + # add a scalebar
    scale_fill_viridis_c(limits = c(0, max_cases), option = "C") + # color the scale to be perceptually uniform
    theme_void() # remove coordinates and axes
  
  # plot with the region on the x axis sorted by increasing ar
  # ar value on the y axis 
  barplot <- ggplot(this_ar, aes(x = reorder(Region, `AR (per 100,000)`),
                                 y = `AR (per 100,000)`)) + 
    geom_bar(stat = "identity", col = "black", fill = "red") + # plot as bars (identity = as is)
    geom_errorbar(aes(ymin = `Lower 95%CI`, ymax = `Upper 95%CI`), width = 0.2) + # add CIs
    scale_y_continuous(expand = c(0, 0), limits = c(0, max_ar)) +  # set origin for axes
    # add labels to axes and below chart
    labs(x = "Region", y = "AR (per 100,000)", 
         captions = paste0("Source: MSF data from ", reporting_week))
  # combine the barplot and map plot into one
  print(
    cowplot::plot_grid(
      barplot + labs(title = paste0("Epiweek:", i)),
      map_plot,
      nrow = 1,
      align = "h",
      axis = "tb"
    )
  )
}
```

