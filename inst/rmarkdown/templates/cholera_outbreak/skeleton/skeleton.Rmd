---
title: "Cholera outbreak report"
output: word_document
---

# Introduction to this template

This is a template which can be used to create an automated outbreak situation
report for cholera. 

- It is organised by time, place and person. 
- You can type normal text in white spaces (such as here) and r-code in grey
    spaces (denoted by three backticks and r) (see [Rmarkdown
    introduction](https://rmarkdown.rstudio.com/articles_intro.html) and
    [Markdown basics](https://rmarkdown.rstudio.com/authoring_basics.html))
- Introductions and contents of sections are within square brackets "[...]" and
    can be deleted as appropriate
- Examples of inline code (to automate updating numbers, e.g. line 148), can
    similarly be removed/updated
- Code itself can be deleted, but as a word of caution: make sure you aren't
    deleting bits where variables are created/manipulated, or at least update
    them appropriatley
- For a more detailed exaplanation of this template, see [Wiki](https://github.com/R4EPI/sitrep/wiki)
- ADD LIST ON WHICH PACKAGES WILL BE USED FOR WHAT REASONS! AND HOW TO INSTALL
- OTHER INFO TO ADD??


```{r setup, include=FALSE}
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = FALSE, error = TRUE, fig.width = 16, fig.height = 12)
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")


library(knitr) # for creating output doc
library(dplyr) # for cleaning/shaping data
library(ggplot2) # for plotting diagrams

# epi packages
library(sitrep) # for msf field epi functions
library(incidence) # for epicurves
library(ISOweek) # for creating epiweeks
library(epitools) # for creating 2by2 tables

#set default text size to 16 for plots
ggplot2::theme_set(theme_bw(base_size = 18))
```




```{r read_data}
## Read data ------------------------------------
# CSV file
# linelist_raw <- rio::import("linelist.csv")
#
# Excel file
# to read in a specific sheet use "which"
# linelist_raw <- rio::import("linelist.xlsx", which = "Sheet1")
#
# Stata data file
# linelist_raw <- rio::import("linelist.dat")
#
# For password protected Excel file 
# use the excel.link package 
# library(excel.link)
# linelist_raw <- excel.link::xl.read.file("linelist.xlsx",
#                                          xl.sheet = "Sheet1",
#                                          password = askpass::askpass(prompt = "please enter file
#                                                                      password"))


# THESE TWO LINES CAN BE DELETED IF YOU HAVE YOUR OWN DATA!
# get MSF data dictionary for cholera 
linelist_dict <- msf_dict("Cholera")

# use fake dataset as an example 
linelist_raw <- gen_data("Cholera")

## Fixing variable names ----------------------

# a good first step is to assign standard column names so that subsequent code
# uses stable column names. 
# in case the input data changes, you just need to fix the column mapping


# make a copy of your original dataset and name it linelist_cleaned
linelist_cleaned <- linelist_raw

# define clean variable names using clean_labels from the epitrix package
# this function is preset rules for variable naming 
# for example it changes spaces and dots to "_" and characters to lowercase
# cleaned_colnames <- epitrix::clean_labels(colnames(linelist_raw))

# overwrite variable names with defined clean names
# colnames(linelist_cleaned) <- cleaned_colnames

# you can also change specific var names using the *rename* function
# linelist_cleaned <- rename(linelist_cleaned, sex = gender)

# only keep variables from data dictionary 
linelist_cleaned <- select(linelist_raw, linelist_dict$shortname_export)
```


```{r read_population_data}

## Read data ------------------------------------

# Excel file
# to read in a specific sheet use "which"
# population_data <- rio::import("population.xlsx", which = "Sheet1")

# repeat same cleaning steps as above
# make sure your place variable name matches!

# THIS CAN BE DELETED IF YOU HAVE YOUR OWN POP DATA! 
# its just to be able to demonstrate script in this template

# generate some artificial population data
population_data <- distinct(linelist_cleaned, patient_origin_free_text)
population_data$population <- as.integer(runif(nrow(population_data), 
                                          min = 500, max = 2000))

```



```{r browse_data, eval = FALSE}
# Browsing data ---------------------------------
# here are a few ways to do data explorations 

# view the first ten rows of data
head(linelist_cleaned, n = 10)

# view your whole dataset interactivley (in an excel style format)
## Remember that `View` needs to be written with a capital *V*
if (interactive()) View(linelist_cleaned)

# overview of variable types and contents
str(linelist_cleaned)

# gives mean, median and max values of variables
summary(linelist_cleaned)

# view unique values contained in variables 
unique(linelist_cleaned$sex)

# another alternative is with the "summarytools package"
# use the dfSummary function in combination with view
# note that view is not capitalised with this package
# install.packages("summarytools")
# view(summarytools::dfSummary(linelist_cleaned))
```






```{r standardise_clean_data}
# Next, document anything to clean data. Use dplyr for that.


# make sure all date variables are formatted as dates 
DATEVARS <- filter(linelist_dict, value_type == "DATE") %>% 
  select(shortname_export) # select date vars
# change to dates 
linelist_cleaned <- linelist_cleaned %>%
  mutate_at(DATEVARS$shortname_export, as.Date)

# if you dont have a data dictionary you could do it this way too
# linelist_cleaned <- linelist_cleaned %>%
#   mutate_at(vars(matches("date|Date")), as.Date)


# create an age group variable by specifying categorical breaks (of years)
linelist_cleaned$age_group <- age_categories(linelist_cleaned$age_years, 
                                             breakers = c(0, 5, 15, 25, 35, 45))

# alternatively, create an age group variable specify a sequence
# linelist_cleaned$age_group <- age_categories(linelist_cleaned$age,
#                                              lower = 0, 
#                                              upper = 100, 
#                                              by = 10)

# If you already have an age group variable defined, you should manually
# arrange the categories
# linelist_cleaned$age_group <- factor(linelist_cleaned$age_group,
#                                      c("0-4y", "5-9y", "10-29y", "30-49y", "50-79y", "80+y"))


# create age group variable for under 5 years based on months
linelist_cleaned$age_group_mon <- if_else(linelist_cleaned$age_group == "0-4", 
                                          age_categories(linelist_cleaned$age_months, 
                                                         breakers = c(0, 5, 8, 11, 23, 59)),  
                                          NA_integer_)
                                       
# Change the levels of a categorical variable
linelist_cleaned$sex <- recode_factor(linelist_cleaned$sex, 
                                      "Male" = "Male", 
                                      "Female" = "Female", 
                                      "Unknown/unspecified" = NA_character_)

# create a case definition variable 
# the tilda (~) is used to assign the new values (Conf, prob, susp, unknown)
linelist_cleaned <- linelist_cleaned %>%
  mutate(case_def = case_when(
    grepl("Positive", .$cholera_pcr_result) |  
      grepl("Positive", .$cholera_culture_result)   ~ "Confirmed",
    cholera_rdt_result == "Positive"                ~ "Probable",
    TRUE                                            ~ "Suspected"
  ))




# fix any misspellings in the data
# linelist_cleaned <- linelist_cleaned %>%
#   mutate(patient_origin_free_text = recode(patient_origin_free_text,
#     # List all incorrect mis-spellings here ("old" = "new")
#     "Valliages DD" = "Village D"
#   ))


# create an epiweek variable 
linelist_cleaned$epiweek <- ISOweek(linelist_cleaned$date_of_onset)

# ... TODO: add some snippets for cleaing data
# TODO: showcase and recommend the linelist package
```



